# Технічне завдання: Базова механіка рівня Color Block Jam

**Версія:** 1.0  
**Дата:** 2025-01-27  
**Статус:** Для розробки  
**Платформи:** iOS 15+, Android 7+ (Flutter)

---

## 1. Огляд та мета

### 1.1 Призначення
Реалізація базової ігрової механіки рівня з візуалізацією, що відповідає оригінальній грі Color Block Jam (Rollic Games). Механіка включає рух кольорових блоків по сітці до відповідних дверей з анімаціями та візуальним фідбеком.

### 1.2 Референс
- **Оригінальна гра:** [Color Block Jam](https://apps.apple.com/us/app/color-block-jam/id6504332779)
- **Аналіз даних:** `res/ColorBlockJam_Analysis/` (1557 рівнів, формат даних)
- **Цільова платформа:** Mobile (iOS/Android через Flutter)

---

## 2. Архітектурні вимоги

### 2.1 Компоненти системи

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│  ┌──────────────┐  ┌─────────────────┐  │
│  │ GameScreen   │  │ AnimationSystem │  │
│  │ (UI Widget)  │  │ (Tween/Animate) │  │
│  └──────────────┘  └─────────────────┘  │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│          Domain Layer                    │
│  ┌──────────────┐  ┌─────────────────┐  │
│  │ LevelState   │  │ Block/Door      │  │
│  │ (Immutable)  │  │ (Models)        │  │
│  └──────────────┘  └─────────────────┘  │
│  ┌──────────────┐  ┌─────────────────┐  │
│  │ GameLogic    │  │ CollisionSystem │  │
│  │ (Pure)       │  │ (Grid-based)    │  │
│  └──────────────┘  └─────────────────┘  │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│          Data Layer                     │
│  ┌──────────────┐  ┌─────────────────┐  │
│  │ LevelLoader  │  │ LevelCache      │  │
│  │ (JSON)       │  │ (Memory)        │  │
│  └──────────────┘  └─────────────────┘  │
└─────────────────────────────────────────┘
```

### 2.2 Принципи архітектури

1. **Immutable State:** `LevelState` - immutable, кожна дія створює новий стан
2. **Separation of Concerns:** Логіка відокремлена від UI, тестована незалежно
3. **Performance:** CustomPainter з оптимізацією перемальовки (RepaintBoundary)
4. **Scalability:** Підтримка різних розмірів сітки (4×5 до 9×9+)
5. **Stability:** Валідація всіх операцій, graceful degradation

---

## 3. Візуальний дизайн (як в оригіналі)

### 3.1 Загальний вигляд рівня

**3D-перспектива (ізометрична/під кутом):**
- Камера розташована під кутом ~45° до горизонту
- Поле має глибину (Z-ось) для 3D ефекту
- Тіні від блоків та дверей для об'ємності
- Градієнтний фон або текстура

**Кольорова палітра (з оригіналу):**
```
Червоний:    #E74C3C (RGB: 231, 76, 60)
Синій:       #2980B9 (RGB: 41, 128, 185)
Зелений:     #27AE60 (RGB: 39, 174, 96)
Жовтий:      #F1C40F (RGB: 241, 196, 15)
Фіолетовий:  #9B59B6 (RGB: 155, 89, 182)
Помаранчевий: #E67E22 (RGB: 230, 126, 34)
Рожевий:     #EC7063 (RGB: 236, 112, 99)
Блакитний:   #5DADE2 (RGB: 93, 173, 226)
```

### 3.2 Сітка (Grid)

**Візуалізація:**
- **Фон сітки:** Світло-сірий (#F5F5F5) або білий з легким градієнтом
- **Лінії сітки:** Тонкі сірі лінії (#E0E0E0), stroke width 1-2px
- **Клітинки:** Квадратні, розмір залежить від розміру екрана
- **Приховані клітинки:** Темніші або з діагональними смугами (hiddenCoords)

**Розміри:**
- Мінімальний розмір клітинки: 48dp (для touch targets)
- Адаптивний розмір: підлаштовується під розмір екрана
- Відступи: Padding 16dp від країв екрана

### 3.3 Блоки (Blocks)

**Візуальний стиль:**
- **Форма:** 3D-куби з заокругленими краями (border radius 8-12px)
- **Тінь:** Drop shadow з blur 4-6px, offset (2, 2)
- **Градієнт:** Лінійний градієнт від світлішого до темнішого відтінку кольору
- **Обводка:** Тонка обводка (1-2px) темнішого відтінку для контрасту
- **Висота:** Візуальна висота ~2-4px для 3D ефекту

**Типи блоків (BlockGroupType):**
```
0. One (1×1):        ■
1. Two (1×2):        ■■
2. Three (1×3):     ■■■
3. L:                ■
                     ■■
4. ReverseL:         ■
                    ■■
5. ShortL:           ■
                    ■■
6. Plus:            ·■·
                    ■■■
                    ·■·
7. TwoSquare (2×2): ■■
                    ■■
8. ShortT:          ■■■
                    ·■·
9. Z:               ■■·
                    ·■■
10. ReverseZ:       ·■■
                    ■■·
11. U:               ■·■
                    ■■■
```

**Анімації блоків:**
- **Вибір:** Масштаб 1.0 → 1.05, тінь збільшується
- **Рух:** Smooth slide з easing curve (Curves.easeOutCubic)
- **Зіткнення:** Легкий bounce (scale 0.95 → 1.0)
- **Зникнення:** Scale 1.0 → 0.0 + fade out (300ms), particle effect (опційно)

**Інтерактивність:**
- **Hover/Touch:** Підсвітка при натисканні
- **Drag preview:** Показувати напрямок руху стрілкою або траєкторією
- **Disabled:** Зменшена прозорість (0.5) для заблокованих блоків

### 3.4 Двері (Doors)

**Візуальний стиль:**
- **Форма:** Прямокутний отвір у сітці з рамкою
- **Колір:** Відповідає кольору блоку (той самий градієнт)
- **Рамка:** Товста обводка (4-6px) кольору дверей
- **Фон:** Прозорість 0.2-0.3 для внутрішньої частини
- **Частини:** Двері можуть складатися з 1-5 частин (doorPartCount)

**Анімації дверей:**
- **Активність:** Пульсація при наближенні блоку (scale 1.0 → 1.05)
- **Відкриття:** Анімація "відкриття" при вході блоку (opacity 1.0 → 0.0)
- **Зірка:** Якщо hasStar=true, зірка обертається над дверима

**Спеціальні стани:**
- **Лід (hasIce):** Білий/блакитний ефект льоду поверх дверей, iceCount шарів
- **Перемикач (isSwitchDoor):** Додатковий індикатор перемикання

### 3.5 Камера та перспектива

**Налаштування камери (з JSON):**
```json
{
  "position": {"x": 0.0, "y": -6.0, "z": -21.0},
  "rotation": {"x": 345.0, "y": 0.0, "z": 0.0},
  "fov": 60.0
}
```

**Реалізація в Flutter:**
- Використовувати `Transform` для 3D перетворень
- Або 2D імітація через skew/scale для псевдо-3D ефекту
- Камера повинна центрувати поле на екрані

**Адаптація:**
- На маленьких екранах: зменшити FOV або відстань
- На планшетах: збільшити поле зору

### 3.6 UI Overlay (інтерфейс поверх гри)

**Верхня панель:**
- **Рівень:** "Level 1" або номер рівня
- **Таймер:** Формат MM:SS (якщо є таймер)
- **Ходи:** "Moves: 15" (якщо є ліміт ходів)
- **Пауза:** Кнопка паузи (іконка)

**Нижня панель (опційно):**
- **Undo:** Кнопка скасування ходу
- **Hint:** Кнопка підказки
- **Restart:** Кнопка перезапуску

**Стиль UI:**
- Напівпрозорий фон (0.8 opacity)
- Закруглені кути (border radius 12px)
- Тінь для відділення від ігрового поля

---

## 4. Ігрова механіка

### 4.1 Основний геймплей

**Ціль:** Перемістити всі блоки у відповідні двері того ж кольору.

**Правила:**
1. Блок рухається по сітці в напрямку свайпу до упору
2. Блок зупиняється при:
   - Досягненні межі сітки
   - Зіткненні з іншим блоком
   - Зіткненні з дверима іншого кольору
3. Блок зникає при вході в двері свого кольору
4. Перемога: всі блоки зникли

### 4.2 Система руху

**Жести:**
- **Swipe/drag:** Основний жест для руху блоку
- **Мінімальна відстань:** ~80px для визначення напрямку
- **Напрямки:** Up, Down, Left, Right (4 напрямки)

**Правило руху (як в оригіналі):**
- Блок рухається по клітинках у вибраному напрямку й може зупинитися на будь-якій вільній клітинці (не лише на краю).
- Рух триває, поки наступна клітинка доступна (всередині сітки, не зайнята блоком, не заблокована дверима іншого кольору).
- Якщо наступна клітинка — двері того ж кольору, блок входить і зникає.

**Алгоритм руху (кроковий):**
```dart
MoveResult? computeMove(BlockId id, GridDirection dir) {
  1. Знайти блок, ініціалізувати path = [start].
  2. dRow/dCol з напряму.
  3. while (можемо йти далі):
     - якщо вихід за межі → break
     - якщо на наступній клітинці інший блок → break
     - якщо двері іншого кольору → break
     - якщо двері того ж кольору → додати в path, removed=true, break
     - інакше: зсунутися на 1 клітинку, додати в path
  4. Якщо path має лише start → руху нема (null).
  5. Оновити стан: або видалити блок (removed), або перемістити в останню клітинку path.
  6. Повернути MoveResult з path для поетапної анімації.
}
```

**Анімація:**
- Інтерполювати між сегментами `path` (кожна пара клітинок) з easeOut.
- Тривалість = крокова_тривалість × (path.length - 1), clamp для мін/макс.

**Оптимізація:**
- Використовувати кеш координат (Map/Set) для швидкого пошуку блоків і дверей.
- Мінімізувати алокації в рендері; тримати paint-об’єкти реюзабельними.

### 4.3 Система колізій

**Типи колізій:**
1. **Блок ↔ Межа сітки:** Перевірка `row < 0 || row >= rows`
2. **Блок ↔ Блок:** Перевірка наявності блоку в клітинці
3. **Блок ↔ Двері:** Перевірка кольору дверей vs кольору блоку

**Реалізація:**
```dart
class CollisionSystem {
  bool canMove(LevelState state, Block block, GridDirection dir) {
    final nextPos = _nextPosition(block, dir);
    if (!_insideBounds(nextPos)) return false;
    if (_hasBlock(state, nextPos)) return false;
    final door = _doorAt(state, nextPos);
    if (door != null && door.color != block.color) return false;
    return true;
  }
}
```

### 4.4 Перевірка перемоги

**Умова перемоги:**
```dart
bool isWin(LevelState state) {
  return state.blocks.isEmpty;
}
```

**Анімація перемоги:**
- Всі блоки зникли → показати "Level Complete!"
- Confetti effect (опційно)
- Перехід до наступного рівня через 1-2 секунди

---

## 5. Технічні вимоги

### 5.1 Продуктивність

**Цільові метрики:**
- **FPS:** Стабільні 60 FPS на mid-range пристроях (Snapdragon 660+)
- **Frame time:** < 16.67ms на кадр
- **Memory:** < 100MB для одного рівня
- **Battery:** Мінімальне споживання (без постійних оновлень)

**Оптимізації:**
- Використовувати `RepaintBoundary` для ізоляції перемальовки
- Кешувати `Paint` об'єкти
- Мінімізувати створення нових об'єктів в paint методах
- Використовувати `shouldRepaint` для умовної перемальовки

### 5.2 Стабільність

**Обробка помилок:**
- Валідація всіх вхідних даних (JSON, жести)
- Graceful degradation при помилках завантаження рівня
- Try-catch для всіх критичних операцій
- Логування помилок (debug режим)

**Тестування:**
- Unit тести для `LevelState.slideBlock`
- Unit тести для `CollisionSystem`
- Widget тести для `GameScreen`
- Інтеграційні тести для повного циклу гри

### 5.3 Сумісність

**Підтримувані розміри екранів:**
- Мінімальний: 320×568 (iPhone SE 1st gen)
- Максимальний: 428×926 (iPhone 14 Pro Max)
- Планшети: iPad (1024×1366)

**Адаптивність:**
- Автоматичне масштабування сітки під розмір екрана
- Збереження пропорцій блоків та дверей
- Адаптація розміру UI елементів

---

## 6. Структура даних

### 6.1 Модель рівня

```dart
class LevelState {
  final List<Block> blocks;
  final List<Door> doors;
  final int rows;
  final int cols;
  final List<Point<int>> hiddenCoords;
  
  // Immutable operations
  LevelState slideBlock(BlockId id, GridDirection dir);
  Block? blockAt(Point<int> cell);
  Door? doorAt(Point<int> cell);
  bool isWin();
}
```

### 6.2 Модель блоку

```dart
class Block {
  final BlockId id;
  final int row;
  final int col;
  final Color color;
  final BlockGroupType shape; // 0-11
  final int width;  // для складних форм
  final int height; // для складних форм
  
  Block copyWith({int? row, int? col});
}
```

### 6.3 Модель дверей

```dart
class Door {
  final int row;
  final int col;
  final Color color;
  final int partCount; // 1-5
  final bool hasStar;
  final bool hasIce;
  final int iceCount;
}
```

### 6.4 Завантаження з JSON

**Формат (з `parsed_levels_complete.json`):**
```json
{
  "name": "Level 1",
  "gridSize": {"x": 4, "y": 5},
  "blocks": [
    {
      "position": {"x": -4.56, "y": 5.52, "z": 0.0},
      "blockGroupType": 0,
      "blockType": 0
    }
  ],
  "doors": [
    {
      "position": {"x": -1.0, "y": -6.0, "z": 0.0},
      "doorPartCount": 3,
      "blockType": 3
    }
  ]
}
```

**Конвертація:**
- Перетворити світові координати (x, y, z) → grid координати (row, col)
- Мапінг blockType → Color
- Мапінг blockGroupType → BlockGroupType enum

---

## 7. Анімації та візуальні ефекти

### 7.1 Анімація руху блоку

**Параметри:**
- **Тривалість:** 200-300ms для одного кроку
- **Easing:** `Curves.easeOutCubic` для плавності
- **Кроки:** Анімація для кожного кроку руху (не один великий рух)

**Реалізація:**
```dart
AnimationController _moveController;
Tween<Offset> _moveTween;

void _animateBlockMove(Block block, Point<int> from, Point<int> to) {
  _moveTween = Tween(
    begin: _cellToOffset(from),
    end: _cellToOffset(to),
  );
  _moveController.forward();
}
```

### 7.2 Анімація зникнення блоку

**Ефект:**
- Scale: 1.0 → 0.0
- Opacity: 1.0 → 0.0
- Тривалість: 300ms
- Particle effect (опційно): маленькі частинки кольору блоку

### 7.3 Візуальний фідбек

**При виборі блоку:**
- Підсвітка (glow effect)
- Масштаб 1.05x
- Вібрація (HapticFeedback.mediumImpact)

**При зіткненні:**
- Легкий bounce (scale 0.95 → 1.0)
- Звук зіткнення (опційно)

**При перемозі:**
- Confetti effect
- "Level Complete!" текст з анімацією
- Звук перемоги

---

## 8. План реалізації

### Фаза 1: Базова механіка (Дні 1-3)
- [ ] Моделі даних (Block, Door, LevelState)
- [ ] Система руху (slideBlock)
- [ ] Система колізій
- [ ] Базовий рендеринг (CustomPainter)
- [ ] Жести (swipe detection)

### Фаза 2: Візуалізація (Дні 4-5)
- [ ] 3D-стиль блоків (градієнти, тіні)
- [ ] Візуалізація дверей
- [ ] Анімації руху
- [ ] Анімації зникнення
- [ ] UI overlay

### Фаза 3: Полірування (Дні 6-7)
- [ ] Конвертер JSON → LevelState
- [ ] Завантаження рівнів з файлу
- [ ] Оптимізація продуктивності
- [ ] Тестування на різних пристроях
- [ ] Багфікси

---

## 9. Критерії прийняття

### Функціональність
- ✅ Блоки рухаються по сітці при свайпі
- ✅ Блоки зупиняються при колізіях
- ✅ Блоки зникають при вході в двері свого кольору
- ✅ Перемога визначається коректно
- ✅ Рівень можна перезапустити

### Візуал
- ✅ Блоки мають 3D-вигляд (градієнти, тіні)
- ✅ Двері візуально відрізняються від блоків
- ✅ Анімації плавні (60 FPS)
- ✅ UI не перекриває ігрове поле

### Продуктивність
- ✅ Стабільні 60 FPS на mid-range пристроях
- ✅ Немає memory leaks
- ✅ Швидке завантаження рівня (< 1 секунда)

### Стабільність
- ✅ Немає crashes при нормальному використанні
- ✅ Graceful handling помилок
- ✅ Валідація всіх вхідних даних

---

## 10. Додаткові нотатки

### Відмінності від оригіналу (для уникнення копіювання)
- Власна колірна схема (можна змінити палітру)
- Інший стиль UI (Material Design замість кастомного)
- Власні звуки та музика
- Інші назви рівнів

### Майбутні розширення (не в MVP)
- Таймер рівня
- Ліміт ходів
- Бустери (undo, hint)
- Різні типи блоків (L, T, Z форми)
- Спеціальні елементи (лід, ключі, замки)

---

**Автор:** Mobile SDK Architect Agent  
**Затверджено:** [Дата]  
**Версія документа:** 1.0

