<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Block Jam - Brute-Force Visualizer</title>
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --accent: #0f3460;
            --primary: #e94560;
            --success: #4ade80;
            --warning: #fbbf24;
            --text: #eee;
            --text-muted: #888;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--primary), #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            color: var(--text-muted);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
        }
        
        .panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
        }
        
        .panel h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--accent);
        }
        
        /* Level Selector */
        .level-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 8px;
            background: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .level-item:hover {
            background: var(--primary);
            transform: translateX(5px);
        }
        
        .level-item.active {
            background: var(--primary);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.4);
        }
        
        .level-item.solved {
            border-left: 3px solid var(--success);
        }
        
        .level-item.unsolved {
            border-left: 3px solid var(--warning);
        }
        
        .level-name {
            font-weight: 500;
        }
        
        .level-status {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        /* Game Canvas */
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            background: #2a2a4a;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #ff5a75;
            transform: translateY(-2px);
        }
        
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: var(--accent);
            color: white;
        }
        
        .btn-secondary:hover {
            background: #1a4a80;
        }
        
        .btn-success {
            background: var(--success);
            color: #111;
        }
        
        .btn-warning {
            background: var(--warning);
            color: #111;
        }
        
        .btn-warning:hover {
            background: #f59e0b;
            transform: translateY(-2px);
        }
        
        /* Stats Panel */
        .stats-grid {
            display: grid;
            gap: 15px;
        }
        
        .stat-card {
            background: var(--accent);
            padding: 15px;
            border-radius: 8px;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .stat-value.success {
            color: var(--success);
        }
        
        .stat-value.warning {
            color: var(--warning);
        }
        
        /* Solution Steps */
        .solution-steps {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .step {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: var(--accent);
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .step:hover {
            background: #1a4a80;
        }
        
        .step.active {
            background: var(--primary);
        }
        
        .step-num {
            width: 24px;
            height: 24px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 0.8rem;
        }
        
        /* Progress Bar */
        .progress-bar {
            height: 4px;
            background: var(--accent);
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Speed Control */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .speed-control label {
            font-size: 0.9rem;
        }
        
        .speed-control input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: var(--accent);
            border-radius: 3px;
        }
        
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* Batch Analysis */
        .batch-results {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .batch-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 4px;
            background: var(--accent);
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .batch-item.solved {
            border-left: 3px solid var(--success);
        }
        
        .batch-item.unsolved {
            border-left: 3px solid #ef4444;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #1a4a80;
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Source Selector */
        .source-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .source-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: var(--accent);
            color: var(--text);
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        .source-selector select:hover {
            background: #1a4a80;
        }
        
        /* Status Bar */
        .status-bar {
            padding: 8px 12px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-bar.success {
            background: rgba(74, 222, 128, 0.2);
            color: var(--success);
        }
        
        .status-bar.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .status-bar.loading {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning);
        }
        
        .status-icon {
            font-size: 1rem;
        }
        
        /* Alert badges */
        .alert-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 5px;
        }
        
        .alert-badge.warning {
            background: rgba(251, 191, 36, 0.3);
            color: var(--warning);
        }
        
        .alert-badge.error {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .stat-value.alert-warning {
            color: var(--warning);
        }
        
        .stat-value.alert-error {
            color: #ef4444;
        }
        
        /* Level item alerts */
        .level-item.alert-warning {
            border-left: 3px solid var(--warning);
        }
        
        .level-item.alert-error {
            border-left: 3px solid #ef4444;
        }
        
        /* Settings Panel */
        .settings-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 5px 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .settings-toggle:hover {
            color: var(--text);
        }
        
        .settings-panel {
            background: var(--accent);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }
        
        .settings-panel.open {
            display: block;
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .setting-row:last-child {
            margin-bottom: 0;
        }
        
        .setting-label {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .setting-input {
            width: 100px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: var(--bg-card);
            color: var(--text);
            font-size: 0.85rem;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Color Block Jam - Brute-Force Visualizer</h1>
            <p class="subtitle">
                v1.8.22-debug | Analyze and visualize level solutions | 
                Game Engine: <span id="gameEngineVersion">v1.0.0</span> |
                <a href="../../docs/BRUTE_FORCE.md" target="_blank" style="color: var(--primary); text-decoration: none;">üìã Docs & Changelog</a>
            </p>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Level List -->
            <div class="panel">
                <h2>Levels</h2>
                <div class="source-selector">
                    <label>Source:</label>
                    <select id="sourceSelect" onchange="changeSource()">
                        <option value="dev">DEV (Local)</option>
                        <option value="prod">PROD (Assets)</option>
                    </select>
                    <button class="btn btn-secondary" onclick="reloadLevels()" style="padding: 8px 12px; font-size: 0.85rem;">
                        üîÑ Reload
                    </button>
                </div>
                <div class="status-bar loading" id="statusBar">
                    <span class="status-icon">‚è≥</span>
                    <span id="statusText">Loading levels...</span>
                </div>
                <div id="fileLastModified" style="margin-top: 8px; font-size: 0.75rem; color: var(--text-muted); text-align: center;">
                    Last modified: <span id="lastModifiedTime">-</span>
                </div>
                <div class="level-list" id="levelList">
                    <!-- Populated by JS -->
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="analysisProgress"></div>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-primary" onclick="analyzeAllLevels()" id="analyzeAllBtn">
                        Analyze All
                    </button>
                </div>
            </div>
            
            <!-- Center: Game Canvas -->
            <div class="panel canvas-container">
                <canvas id="gameCanvas" width="500" height="600"></canvas>
                <div class="controls">
                    <button class="btn btn-primary" onclick="solveCurrent()" id="solveBtn">
                        Solve Level
                    </button>
                    <button class="btn btn-secondary" onclick="playStep(-1)">
                        ‚óÄ Prev
                    </button>
                    <button class="btn btn-success" onclick="toggleAutoPlay()" id="playBtn">
                        ‚ñ∂ Play
                    </button>
                    <button class="btn btn-secondary" onclick="playStep(1)">
                        Next ‚ñ∂
                    </button>
                    <button class="btn btn-secondary" onclick="resetLevel()">
                        Reset
                    </button>
                </div>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="100" max="2000" value="500">
                    <span id="speedValue">500ms</span>
                </div>
                <div id="infoLog" style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; font-size: 0.8rem; color: var(--text-muted); max-height: 80px; overflow-y: auto;">
                    Ready. Select a level to start.
                </div>
                <div id="continueAnywayContainer" style="margin-top: 10px; display: none;">
                    <button class="btn btn-warning" onclick="continueWithHigherLimit()" id="continueAnywayBtn" style="width: 100%; background: var(--warning); color: #111;">
                        ‚ö° Continue with Higher Limit (2x)
                    </button>
                </div>
            </div>
            
            <!-- Right Panel: Stats -->
            <div class="panel">
                <h2>Level Info</h2>
                <div class="stats-grid" id="levelInfo" style="margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="stat-card" style="padding: 10px;">
                            <div class="stat-label">Grid Size</div>
                            <div class="stat-value" id="gridSizeValue" style="font-size: 1.2rem;">-</div>
                        </div>
                        <div class="stat-card" style="padding: 10px;">
                            <div class="stat-label">Blocks</div>
                            <div class="stat-value" id="blocksValue" style="font-size: 1.2rem;">-</div>
                        </div>
                        <div class="stat-card" style="padding: 10px;">
                            <div class="stat-label">Doors</div>
                            <div class="stat-value" id="doorsValue" style="font-size: 1.2rem;">-</div>
                        </div>
                        <div class="stat-card" style="padding: 10px;">
                            <div class="stat-label">Colors</div>
                            <div class="stat-value" id="colorsValue" style="font-size: 1.2rem;">-</div>
                        </div>
                    </div>
                    <div class="stat-card" style="padding: 10px; margin-top: 10px;">
                        <div class="stat-label">Special Blocks</div>
                        <div id="specialBlocksValue" style="font-size: 0.85rem; color: var(--text-muted);">-</div>
                    </div>
                </div>
                
                <h2>Analysis</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Status</div>
                        <div class="stat-value" id="statusValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Minimum Moves</div>
                        <div class="stat-value" id="movesValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">States Explored</div>
                        <div class="stat-value" id="statesValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Search Time</div>
                        <div class="stat-value" id="timeValue">-</div>
                    </div>
                </div>
                
                <h2 style="margin-top: 20px;">Solution Steps</h2>
                <div class="solution-steps" id="solutionSteps">
                    <p style="color: var(--text-muted);">Click "Solve Level" to find solution</p>
                </div>
                
                <h2 style="margin-top: 20px;">Batch Results</h2>
                <div class="batch-results" id="batchResults">
                    <p style="color: var(--text-muted);">Click "Analyze All" to run batch analysis</p>
                </div>
                
                <button class="settings-toggle" onclick="toggleSettings()">
                    ‚öôÔ∏è Settings <span id="settingsArrow">‚ñº</span>
                </button>
                <div class="settings-panel" id="settingsPanel">
                    <div class="setting-row">
                        <span class="setting-label">Max States:</span>
                        <input type="number" class="setting-input" id="maxStatesInput" value="500000" min="1000" max="2000000" onchange="updateSettings()">
                    </div>
                    <div class="setting-row">
                        <span class="setting-label">Warning States:</span>
                        <input type="number" class="setting-input" id="warnStatesInput" value="30000" min="1000" max="100000" onchange="updateSettings()">
                    </div>
                    <div class="setting-row">
                        <span class="setting-label">Warning Time (ms):</span>
                        <input type="number" class="setting-input" id="warnTimeInput" value="30000" min="1000" max="300000" onchange="updateSettings()">
                    </div>
                </div>
                
                <h2 style="margin-top: 20px;">Export / View</h2>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="viewFullStats()" id="viewStatsBtn" disabled>
                        üìä View Stats
                    </button>
                    <button class="btn btn-secondary" onclick="exportJSON()" id="exportJSONBtn" disabled>
                        üìÑ JSON
                    </button>
                    <button class="btn btn-secondary" onclick="exportMarkdown()" id="exportMDBtn" disabled>
                        üìù MD
                    </button>
                    <button class="btn btn-secondary" onclick="exportHTML()" id="exportHTMLBtn" disabled>
                        üåê HTML
                    </button>
                    <button class="btn btn-success" onclick="saveBruteForceStatsToLevelFile()" id="saveToLevelBtn" disabled>
                        üíæ Save to Level File
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============ CONSTANTS ============
    const SOURCES = {
        dev: '../../../assets/levels/levels_27.json',
        prod: 'level_data/parsed_levels_complete.json'
    };
    let currentSource = 'dev';
    
    // Game Engine version (sync with game_models.dart)
    const GAME_ENGINE_VERSION = 'v1.8.27';
    
    // Debug mode - set to true to enable console logging
    const DEBUG = false;
    
    const COLORS = [
        '#03a5ef', // 0 Blue
        '#143cf6', // 1 Dark Blue
        '#48aa1a', // 2 Green
        '#b844c8', // 3 Pink
        '#7343db', // 4 Purple
        '#fbb32d', // 5 Yellow
        '#09521d', // 6 Dark Green
        '#f2772b', // 7 Orange
        '#b8202c', // 8 Red
        '#0facae', // 9 Cyan
    ];

    // Shapes from game_models.dart - format: [col_offset, row_offset]
    // Point(row + offset[1], col + offset[0])
    const SHAPES = {
        0: [[0, 0]],                                          // One (1 cell)
        1: [[0, -1], [0, 0]],                                 // Two (vertical)
        2: [[0, -1], [0, 0], [0, 1]],                         // Three (vertical)
        3: [[0, -1], [0, 0], [0, 1], [1, 1]],                 // L
        4: [[-1, -1], [0, -1], [-1, 0], [-1, 1]],             // ReverseL
        5: [[-1, -1], [0, -1], [0, 0]],                       // ShortL
        6: [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]],        // Plus
        7: [[-1, -1], [0, -1], [-1, 0], [0, 0]],              // TwoSquare (2x2)
        8: [[-1, 0], [0, 0], [1, 0], [0, 1]],                 // ShortT
        9: [[0, 0], [1, 0], [1, 1], [2, 1]],                  // Z
        10: [[1, 0], [2, 0], [0, 1], [1, 1]],                 // ReverseZ
        11: [[0, 0], [2, 0], [0, 1], [1, 1], [2, 1]],         // U
    };

    const MOVE_DIRS = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
    const DELTAS = {
        UP: [-1, 0],
        DOWN: [1, 0],
        LEFT: [0, -1],
        RIGHT: [0, 1]
    };

    // ============ STATE ============
    let levels = [];
    let currentLevel = null;
    let currentLevelIndex = 0;
    let gameState = null;
    let solution = null;
    let currentStep = -1;
    let isPlaying = false;
    let playInterval = null;
    let analysisResults = new Map();
    
    // Animation state
    let isAnimating = false;
    let animationProgress = 0;
    let animationStartTime = 0;
    let animationDuration = 250; // ms per move
    let prevBlockPositions = null; // Map: blockIndex -> {row, col}
    let animatingBlockIndex = -1;
    let animationCallback = null;
    let exitingBlockData = null; // {index, block, cells, direction} - for animating exit

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ============ LEVEL LOADER ============
    function updateStatusBar(type, message) {
        const bar = document.getElementById('statusBar');
        const text = document.getElementById('statusText');
        bar.className = 'status-bar ' + type;
        const icons = { success: '‚úÖ', error: '‚ùå', loading: '‚è≥' };
        bar.querySelector('.status-icon').textContent = icons[type] || 'üìã';
        text.textContent = message;
    }
    
    function changeSource() {
        currentSource = document.getElementById('sourceSelect').value;
        loadLevels();
    }
    
    function reloadLevels() {
        loadLevels();
    }
    
    async function loadLevels() {
        updateStatusBar('loading', 'Loading levels...');
        const startTime = Date.now();
        
        try {
            const url = SOURCES[currentSource];
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            // Get last modified time from response headers
            const lastModified = response.headers.get('Last-Modified');
            if (lastModified) {
                const modDate = new Date(lastModified);
                const formattedDate = modDate.toLocaleString('uk-UA', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                document.getElementById('lastModifiedTime').textContent = formattedDate;
            } else {
                // Fallback: try HEAD request
                try {
                    const headResponse = await fetch(url, { method: 'HEAD' });
                    const headModified = headResponse.headers.get('Last-Modified');
                    if (headModified) {
                        const modDate = new Date(headModified);
                        const formattedDate = modDate.toLocaleString('uk-UA', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        document.getElementById('lastModifiedTime').textContent = formattedDate;
                    }
                } catch (e) {
                    document.getElementById('lastModifiedTime').textContent = 'Unknown';
                }
            }
            
            const data = await response.json();
            levels = data.levels || data;
            
            const elapsed = Date.now() - startTime;
            const sourceName = currentSource.toUpperCase();
            updateStatusBar('success', `${sourceName}: ${levels.length} levels loaded (${elapsed}ms)`);
            log(`‚úÖ Loaded ${levels.length} levels from ${sourceName}`);
            
            renderLevelList();
            if (levels.length > 0) {
                selectLevel(0);
            }
        } catch (e) {
            console.error('Failed to load levels:', e);
            updateStatusBar('error', `ERROR: ${e.message}`);
            document.getElementById('levelList').innerHTML = 
                '<p style="color: #ef4444;">Failed to load levels. Make sure to run from a local server.</p>';
            document.getElementById('lastModifiedTime').textContent = 'Error';
        }
    }

    // Alert thresholds
    const ALERTS = {
        maxStatesWarning: 30000,
        maxStatesError: 50000,
        maxTimeWarning: 30000,
        maxTimeError: 60000
    };
    
    function getAlertClass(result) {
        if (!result) return '';
        if (!result.isSolvable) return 'alert-error';
        if (result.statesExplored >= ALERTS.maxStatesError || result.searchTime >= ALERTS.maxTimeError) return 'alert-error';
        if (result.statesExplored >= ALERTS.maxStatesWarning || result.searchTime >= ALERTS.maxTimeWarning) return 'alert-warning';
        return 'solved';
    }
    
    function renderLevelList() {
        const container = document.getElementById('levelList');
        container.innerHTML = levels.map((level, i) => {
            const result = analysisResults.get(level.id);
            let alertClass = '';
            let statusText = '';
            let alertBadge = '';
            
            if (result) {
                alertClass = getAlertClass(result);
                if (result.isSolvable) {
                    statusText = `${result.minMoves} moves`;
                    if (result.statesExplored >= ALERTS.maxStatesWarning) {
                        alertBadge = '<span class="alert-badge warning">‚ö†Ô∏è HIGH</span>';
                    }
                } else {
                    statusText = 'FAIL';
                    alertBadge = '<span class="alert-badge error">‚ùå</span>';
                }
            }
            return `
                <div class="level-item ${i === currentLevelIndex ? 'active' : ''} ${alertClass}" 
                     onclick="selectLevel(${i})">
                    <span class="level-name">Level ${level.id}${alertBadge}</span>
                    <span class="level-status">${statusText}</span>
                </div>
            `;
        }).join('');
    }

    function selectLevel(index) {
        currentLevelIndex = index;
        currentLevel = levels[index];
        resetLevel();
        renderLevelList();
        updateLevelInfo();
        
        const result = analysisResults.get(currentLevel.id);
        if (result) {
            displayResult(result);
        } else {
            clearStats();
        }
    }
    
    function updateLevelInfo() {
        if (!currentLevel) return;
        
        const blocks = currentLevel.blocks || [];
        const doors = currentLevel.doors || [];
        
        // Grid size
        document.getElementById('gridSizeValue').textContent = 
            `${currentLevel.gridWidth}√ó${currentLevel.gridHeight}`;
        
        // Blocks count
        document.getElementById('blocksValue').textContent = blocks.length;
        
        // Doors count
        document.getElementById('doorsValue').textContent = doors.length;
        
        // Unique colors
        const colors = new Set(blocks.map(b => b.blockType));
        document.getElementById('colorsValue').textContent = colors.size;
        
        // Duration & Hardness
        const duration = currentLevel.duration || currentLevel.levelDuration || '-';
        const hardness = currentLevel.hardness ?? currentLevel.levelHardness ?? '-';
        const hardnessLabels = {0: 'Easy', 1: 'Normal', 2: 'Hard'};
        const hardnessText = typeof hardness === 'number' ? hardnessLabels[hardness] || hardness : hardness;
        
        // Special blocks
        const frozen = blocks.filter(b => (b.iceCount || 0) > 0).length;
        const multilayer = blocks.filter(b => b.innerBlockType >= 0 && b.innerBlockType <= 9).length;
        const horizontal = blocks.filter(b => b.moveDirection === 0).length;
        const vertical = blocks.filter(b => b.moveDirection === 1).length;
        
        let specials = [];
        if (duration !== '-') specials.push(`‚è±Ô∏è ${duration}s`);
        if (hardnessText !== '-') specials.push(`üìä ${hardnessText}`);
        if (frozen > 0) specials.push(`‚ùÑÔ∏è ${frozen}`);
        if (multilayer > 0) specials.push(`üî≤ ${multilayer}`);
        if (horizontal > 0) specials.push(`‚ÜîÔ∏è ${horizontal}`);
        if (vertical > 0) specials.push(`‚ÜïÔ∏è ${vertical}`);
        
        document.getElementById('specialBlocksValue').textContent = 
            specials.length > 0 ? specials.join(' | ') : 'None';
    }

    // ============ GAME STATE ============
    function createState(level) {
        return {
            blocks: level.blocks.map(b => ({...b})),
            doors: level.doors,
            gridWidth: level.gridWidth,
            gridHeight: level.gridHeight,
            hiddenCells: level.hiddenCells || [],
            exitedBlocks: new Set(),
        };
    }

    function cloneState(state) {
        return {
            blocks: state.blocks.map(b => ({...b})),
            doors: state.doors,
            gridWidth: state.gridWidth,
            gridHeight: state.gridHeight,
            hiddenCells: state.hiddenCells,
            exitedBlocks: new Set(state.exitedBlocks),
        };
    }

    function getBlockCells(block, gridHeight = 10) {
        // Use the same logic as game_models.dart _baseCells
        let shape = SHAPES[block.blockGroupType] || [[0, 0]];
        let row = block.gridRow;
        let col = block.gridCol;
        const rotZ = (block.rotationZ || 0) % 4;
        
        // Apply rotation: same as Dart code
        let rotatedShape = shape.map(cell => [...cell]);
        for (let i = 0; i < rotZ; i++) {
            rotatedShape = rotatedShape.map(cell => [-cell[1], cell[0]]);
        }
        
        // Apply special cases for different block types (from game_models.dart)
        const gt = block.blockGroupType;
        
        if (gt === 1) { // Two (Double)
            if (rotZ === 1) col -= 1;
            else if (rotZ === 2) row -= 1;
        } else if (gt === 3) { // L
            if (rotZ === 0) {
                rotatedShape = [[0, -1], [1, -1], [1, 0], [1, 1]];
                col -= 1;
            } else if (rotZ === 2) {
                rotatedShape = [[0, -1], [0, 0], [0, 1], [1, 1]];
                col -= 1;
            }
        } else if (gt === 4) { // ReverseL
            const reverseLShapes = {
                0: [[-1, -1], [0, -1], [-1, 0], [-1, 1]],
                1: [[-1, -1], [-1, 0], [0, 0], [1, 0]],
                2: [[1, -1], [1, 0], [0, 1], [1, 1]],
                3: [[-1, 0], [0, 0], [1, 0], [1, 1]],
            };
            rotatedShape = reverseLShapes[rotZ] || rotatedShape;
            if (rotZ === 2) col -= 1;
            else if (rotZ === 3) row -= 1;
        } else if (gt === 5) { // ShortL
            if (rotZ === 0) {
                rotatedShape = [[-1, -1], [0, -1], [0, 0]];
            } else if (rotZ === 1) {
                rotatedShape = [[0, 0], [1, 0], [0, 1]];
                row -= 1;
                col -= 1;
            } else if (rotZ === 2) {
                rotatedShape = [[0, 0], [0, 1], [1, 1]];
                col -= 1;
                // Check atTopEdge or atBottomEdge (from game_models.dart)
                if (block.needsRowOffset) {
                    row -= 1;
                } else {
                    const atTopEdge = row <= 1;
                    const atBottomEdge = (row + 1) >= gridHeight;
                    if (atTopEdge || atBottomEdge) row -= 1;
                }
            } else if (rotZ === 3) {
                rotatedShape = [[-1, 0], [0, -1], [0, 0]];
            }
        } else if (gt === 8) { // ShortT
            const shortTShapes = {
                0: [[-1, 0], [0, 0], [1, 0], [0, 1]],
                1: [[0, -1], [0, 0], [1, 0], [0, 1]],
                2: [[0, -1], [-1, 0], [0, 0], [1, 0]],
                3: [[0, -1], [-1, 0], [0, 0], [0, 1]]
            };
            rotatedShape = shortTShapes[rotZ] || rotatedShape;
            if (rotZ === 0) row -= 1;
            else if (rotZ === 1) col -= 1;
            else if (rotZ === 2) {
                // Offset only for blocks in upper half of grid (position.y > 0)
                // position.y ‚âà gridHeight/2 - gridRow - 0.5
                // position.y > 0 when gridRow < gridHeight/2 - 0.5
                const isUpperHalf = row < (gridHeight / 2 - 0.5);
                if (isUpperHalf) {
                    row += 1;
                }
            }
        }
        
        // Convert to cells: Point(row + offset[1], col + offset[0])
        return rotatedShape.map(offset => ({
            row: row + offset[1],
            col: col + offset[0]
        }));
    }

    function rotateShape(shape, rotation) {
        // Not used anymore - rotation handled inline
        return shape;
    }

    function stateKey(state) {
        return state.blocks.map((b, i) => 
            state.exitedBlocks.has(i) ? 'X' : `${b.gridRow},${b.gridCol}${b.outerLayerDestroyed ? 'd' : ''}`
        ).join(';');
    }

    // ============ BRUTE-FORCE SOLVER ============
    
    /**
     * Checks if block can exit by moving in ONE direction only (no turns needed)
     * Returns: { canExit: boolean, direction: string, stepsToExit: number, door: object } or null
     */
    function hasDirectPath(state, blockIndex) {
        const block = state.blocks[blockIndex];
        if (state.exitedBlocks.has(blockIndex)) return null;
        if ((block.iceCount || 0) > 0) return null;
        
        // Multi-layer blocks with outer layer intact need 2 moves (remove layer + exit)
        // They don't have a "direct path" - handle them in Phase 2 (A*)
        const hasOuterLayer = block.innerBlockType >= 0 && 
                              block.innerBlockType <= 9 && 
                              !block.outerLayerDestroyed;
        if (hasOuterLayer) return null;
        
        const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
        const cells = getBlockCells(block, state.gridHeight);
        
        // Find compatible doors
        for (const door of state.doors) {
            if (door.blockType !== blockType) continue;
            
            const direction = { top: 'UP', bottom: 'DOWN', left: 'LEFT', right: 'RIGHT' }[door.edge];
            const [dRow, dCol] = DELTAS[direction];
            
            // Check if block is aligned with door
            const doorCells = getDoorCells(door);
            const isAligned = checkAlignment(cells, doorCells, door.edge, state);
            
            if (!isAligned) continue;
            
            // Count steps to exit and check for obstacles
            let steps = 0;
            let blocked = false;
            let testBlock = { ...block };
            
            while (!blocked) {
                steps++;
                testBlock = { ...testBlock, gridRow: testBlock.gridRow + dRow, gridCol: testBlock.gridCol + dCol };
                const testCells = getBlockCells(testBlock, state.gridHeight);
                
                // Check if any cell would exit
                let wouldExit = false;
                for (const cell of testCells) {
                    if (isDoorExit(state, cell.row, cell.col, blockType, direction)) {
                        wouldExit = true;
                    }
                }
                
                if (wouldExit) {
                    return { canExit: true, direction, stepsToExit: steps, door };
                }
                
                // Check for collisions or out of bounds
                for (const cell of testCells) {
                    // Skip cells that would be on door
                    if (isDoorExit(state, cell.row, cell.col, blockType, direction)) continue;
                    
                    if (cell.row < 0 || cell.row >= state.gridHeight ||
                        cell.col < 0 || cell.col >= state.gridWidth) {
                        blocked = true;
                        break;
                    }
                    if (hasCollision(state, blockIndex, cell.row, cell.col)) {
                        blocked = true;
                        break;
                    }
                    if (isHidden(state, cell.row, cell.col)) {
                        blocked = true;
                        break;
                    }
                }
                
                // Safety limit
                if (steps > 20) {
                    blocked = true;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Check if block cells are aligned with door cells
     */
    function checkAlignment(blockCells, doorCells, edge, state) {
        if (edge === 'top' || edge === 'bottom') {
            // For top/bottom doors: ALL UNIQUE block columns must be within door columns
            const doorCols = doorCells.map(c => c.col);
            const uniqueBlockCols = [...new Set(blockCells.map(c => c.col))];
            return uniqueBlockCols.every(col => doorCols.includes(col));
        } else {
            // For left/right doors: ALL UNIQUE block rows must be within door rows
            const doorRows = doorCells.map(c => c.row);
            const uniqueBlockRows = [...new Set(blockCells.map(c => c.row))];
            return uniqueBlockRows.every(row => doorRows.includes(row));
        }
    }

    function getPossibleMoves(state) {
        const moves = [];
        
        state.blocks.forEach((block, i) => {
            if (state.exitedBlocks.has(i)) return;
            if ((block.iceCount || 0) > 0) return;
            
            const moveDir = block.moveDirection ?? 2;
            const canH = moveDir === 0 || moveDir === 2;
            const canV = moveDir === 1 || moveDir === 2;
            
            if (canH) {
                if (canMove(state, i, 'LEFT')) moves.push({blockIndex: i, direction: 'LEFT'});
                if (canMove(state, i, 'RIGHT')) moves.push({blockIndex: i, direction: 'RIGHT'});
            }
            if (canV) {
                if (canMove(state, i, 'UP')) moves.push({blockIndex: i, direction: 'UP'});
                if (canMove(state, i, 'DOWN')) moves.push({blockIndex: i, direction: 'DOWN'});
            }
        });
        
        return moves;
    }

    function canMove(state, blockIndex, direction) {
        const block = state.blocks[blockIndex];
        const cells = getBlockCells(block, state.gridHeight);
        const [dRow, dCol] = DELTAS[direction];
        const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
        
        // Find the best door for this block and direction
        // This already checks if block is ALIGNED with door (canBlockExitThroughDoor)
        const door = getBestDoorForBlock(state, block, direction);
        const blockCanExitThroughDoor = door !== null;
        
        
        let exitingCells = 0;
        
        for (const cell of cells) {
            const newRow = cell.row + dRow;
            const newCol = cell.col + dCol;
            
            // Check if cell would land on door position
            if (isDoorExit(state, newRow, newCol, blockType, direction)) {
                // Cell is on door, but ONLY allow if block is aligned with door
                if (blockCanExitThroughDoor) {
                    exitingCells++;
                    continue; // Block is aligned - cell can exit
                }
                // Block is NOT aligned - treat as blocked (can't exit through misaligned door)
                return false;
            }
            
            // Cell goes out of bounds
            if (newRow < 0 || newRow >= state.gridHeight ||
                newCol < 0 || newCol >= state.gridWidth) {
                // Only allow exit if block is aligned with door
                if (blockCanExitThroughDoor && canExitThroughDoorEdge(door, cell, newRow, newCol, direction)) {
                    exitingCells++;
                    continue;
                }
                return false;
            }
            if (hasCollision(state, blockIndex, newRow, newCol)) return false;
            if (isHidden(state, newRow, newCol)) return false;
            }
            
        // If cells would exit but block isn't aligned with door - blocked
        if (exitingCells > 0 && !blockCanExitThroughDoor) {
                return false;
        }
        
        // Multi-layer blocks aligned with door can always move (applyMove handles slide)
        return true;
    }
    
    function getDoorEdgeForType(state, blockType) {
        for (const door of state.doors) {
            if (door.blockType === blockType) {
                return door.edge;
            }
        }
        return null;
    }
    
    function getDoorForType(state, blockType) {
        // Return first matching door (for simple cases)
        for (const door of state.doors) {
            if (door.blockType === blockType) {
                return door;
            }
        }
        return null;
    }
    
    function getAllDoorsForType(state, blockType) {
        // Return ALL doors for this block type
        return state.doors.filter(door => door.blockType === blockType);
    }
    
    function getBestDoorForBlock(state, block, direction) {
        const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
        const doors = getAllDoorsForType(state, blockType);
        
        // Find door that matches direction and block can exit through
        for (const door of doors) {
            const doorDirection = door.edge === 'top' ? 'UP' : door.edge === 'bottom' ? 'DOWN' : door.edge === 'left' ? 'LEFT' : 'RIGHT';
            if (doorDirection === direction && canBlockExitThroughDoor(state, block, door, direction)) {
                return door;
            }
        }
        return null;
    }
    
    function canExitThroughDoorEdge(door, cell, newRow, newCol, direction) {
        // Cell is going out of bounds - check if it's aligned with door
        if (door.edge === 'bottom' && direction === 'DOWN') {
            // For bottom door, cell's col must be within door's column range
            const doorStartCol = door.startCol;
            const doorEndCol = door.startCol + door.partCount - 1;
            return cell.col >= doorStartCol && cell.col <= doorEndCol;
        }
        if (door.edge === 'top' && direction === 'UP') {
            const doorStartCol = door.startCol;
            const doorEndCol = door.startCol + door.partCount - 1;
            return cell.col >= doorStartCol && cell.col <= doorEndCol;
        }
        if (door.edge === 'left' && direction === 'LEFT') {
            const doorStartRow = door.startRow;
            const doorEndRow = door.startRow + door.partCount - 1;
            return cell.row >= doorStartRow && cell.row <= doorEndRow;
        }
        if (door.edge === 'right' && direction === 'RIGHT') {
            const doorStartRow = door.startRow;
            const doorEndRow = door.startRow + door.partCount - 1;
            return cell.row >= doorStartRow && cell.row <= doorEndRow;
        }
        return false;
    }
    
    /**
     * Check if block can exit through a door
     * 50%+ cells must be aligned with door range in the relevant axis
     * (matches game's exit rule for large blocks through narrow doors)
     */
    function canBlockExitThroughDoor(state, block, door, direction) {
        const cells = getBlockCells(block, state.gridHeight);
        const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
        
        if (door.edge === 'bottom' || door.edge === 'top') {
            // For vertical movement (up/down): ALL UNIQUE columns must be within door
            const doorStartCol = door.startCol;
            const doorEndCol = door.startCol + door.partCount - 1;
            const uniqueCols = [...new Set(cells.map(c => c.col))];
            DEBUG && console.log(`[canBlockExitThroughDoor] Block type=${blockType} gt=${block.blockGroupType} at (${block.gridRow},${block.gridCol}), door=${door.edge} cols ${doorStartCol}-${doorEndCol}, uniqueCols=[${uniqueCols}], cells=${JSON.stringify(cells)}`);
            for (const col of uniqueCols) {
                if (col < doorStartCol || col > doorEndCol) {
                    DEBUG && console.log(`[canBlockExitThroughDoor] FAIL: col ${col} outside door range`);
                    return false;
                }
            }
        } else if (door.edge === 'left' || door.edge === 'right') {
            // For horizontal movement (left/right): ALL UNIQUE rows must be within door
            const doorStartRow = door.startRow;
            const doorEndRow = door.startRow + door.partCount - 1;
            const uniqueRows = [...new Set(cells.map(c => c.row))];
            DEBUG && console.log(`[canBlockExitThroughDoor] Block type=${blockType} gt=${block.blockGroupType} at (${block.gridRow},${block.gridCol}), door=${door.edge} rows ${doorStartRow}-${doorEndRow}, uniqueRows=[${uniqueRows}], cells=${JSON.stringify(cells)}`);
            for (const row of uniqueRows) {
                if (row < doorStartRow || row > doorEndRow) {
                    DEBUG && console.log(`[canBlockExitThroughDoor] FAIL: row ${row} outside door range`);
                    return false;
                }
            }
        }
        
        DEBUG && console.log(`[canBlockExitThroughDoor] SUCCESS: block aligned with door`);
        // All unique rows/cols are within door range
        return true;
    }

    function isDoorExit(state, row, col, blockType, direction) {
        for (const door of state.doors) {
            if (door.blockType !== blockType) continue;
            
            const doorCells = getDoorCells(door);
            for (const dc of doorCells) {
                if (dc.row === row && dc.col === col) {
                    if (door.edge === 'top' && direction === 'UP') return true;
                    if (door.edge === 'bottom' && direction === 'DOWN') return true;
                    if (door.edge === 'left' && direction === 'LEFT') return true;
                    if (door.edge === 'right' && direction === 'RIGHT') return true;
                }
            }
        }
        return false;
    }

    function getDoorCells(door) {
        const cells = [];
        for (let i = 0; i < door.partCount; i++) {
            if (door.edge === 'left') {
                // Left door: cells are at col=-1 (outside grid)
                cells.push({row: door.startRow + i, col: -1});
            } else if (door.edge === 'right') {
                // Right door: cells are at col=gridWidth (outside grid)
                // Use startCol + 1 since startCol is at the edge
                cells.push({row: door.startRow + i, col: door.startCol + 1});
            } else {
                // Top/bottom doors: already have correct row (-1 or gridHeight)
                cells.push({row: door.startRow, col: door.startCol + i});
            }
        }
        return cells;
    }

    function hasCollision(state, movingIndex, row, col) {
        for (let i = 0; i < state.blocks.length; i++) {
            if (i === movingIndex || state.exitedBlocks.has(i)) continue;
            const cells = getBlockCells(state.blocks[i], state.gridHeight);
            if (cells.some(c => c.row === row && c.col === col)) return true;
        }
        return false;
    }

    function isHidden(state, row, col) {
        return state.hiddenCells.some(h => h.row === row && h.col === col);
    }

    function applyMove(state, move) {
        const newState = cloneState(state);
        const block = newState.blocks[move.blockIndex];
        const [dRow, dCol] = DELTAS[move.direction];
        const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
        
            const cells = getBlockCells(block, state.gridHeight);
        let exitingCells = 0;
        let movableCells = 0;
        let blockedCells = 0;
        
        // Get best door for this block and direction
        // This already checks if block is ALIGNED with door (canBlockExitThroughDoor)
        const door = getBestDoorForBlock(newState, block, move.direction);
        const blockCanExitThroughDoor = door !== null;
        
        // Check each cell
            for (const cell of cells) {
                const newRow = cell.row + dRow;
                const newCol = cell.col + dCol;
                
            // Check if cell would land on door position
                if (isDoorExit(newState, newRow, newCol, blockType, move.direction)) {
                // Cell is on door, but ONLY count as exiting if block is aligned
                if (blockCanExitThroughDoor) {
                    exitingCells++;
                } else {
                    // Block NOT aligned - this cell is blocked (can't pass through misaligned door)
                    blockedCells++;
                }
                continue;
            }
            
            // Check bounds
            if (newRow < 0 || newRow >= state.gridHeight ||
                newCol < 0 || newCol >= state.gridWidth) {
                // Cell goes out of bounds - check if it can exit through door edge
                if (blockCanExitThroughDoor && canExitThroughDoorEdge(door, cell, newRow, newCol, move.direction)) {
                    exitingCells++;
                } else {
                    blockedCells++;
                }
                continue;
            }
            
            // Check collision
                if (hasCollision(newState, move.blockIndex, newRow, newCol)) {
                blockedCells++;
                continue;
                }
                
            // Check hidden cells
                if (isHidden(newState, newRow, newCol)) {
                blockedCells++;
                continue;
            }
            
            movableCells++;
        }
        
        // Block can move if no cells are blocked
        const canMoveBlock = (blockedCells === 0);
        // Block exits when 50%+ cells are through the door (game auto-pulls block in)
        const exitThreshold = Math.ceil(cells.length / 2); // 50% rounded up
        
        // Check if this is a multi-layer block
        const hasOuterLayer = block.innerBlockType >= 0 && block.innerBlockType <= 9 && !block.outerLayerDestroyed;
        
        // Block exits if:
        // 1. It's FULLY aligned with door (100% cells in door range - checked in blockCanExitThroughDoor)
        // 2. At least 1 cell touches/reaches the door position
        // 3. No blocked cells (other blocks/walls don't obstruct the movement)
        // This matches game behavior: fully aligned block exits when ANY part touches door AND path is clear
        const willExit = blockCanExitThroughDoor && (exitingCells > 0) && (blockedCells === 0);
        
        DEBUG && console.log(`[applyMove] Block ${move.blockIndex} type=${blockType} dir=${move.direction}: exitingCells=${exitingCells}, blockedCells=${blockedCells}, canExitThroughDoor=${blockCanExitThroughDoor}, willExit=${willExit}, hasOuterLayer=${hasOuterLayer}`);
            
            if (willExit) {
            DEBUG && console.log(`[applyMove] Block ${move.blockIndex} WILL EXIT! hasOuterLayer=${hasOuterLayer}`);
            if (hasOuterLayer) {
                // Outer layer is destroyed, but block stays on field (doesn't move into door)
                // Block remains at current position, only outer layer is removed
                DEBUG && console.log(`[applyMove] Removing outer layer from block ${move.blockIndex}`);
                    block.outerLayerDestroyed = true;
                } else {
                // Block actually exits - move it and mark as exited
                block.gridRow += dRow;
                block.gridCol += dCol;
                    newState.exitedBlocks.add(move.blockIndex);
                    // Update ice counts
                    newState.blocks.forEach((b, i) => {
                        if (!newState.exitedBlocks.has(i) && (b.iceCount || 0) > 0) {
                            b.iceCount--;
                        }
                    });
                }
            return newState;
        }
        
        // If block can move (but not exit)
        if (canMoveBlock) {
            // If cells would exit but block isn't aligned - don't allow
            if (exitingCells > 0 && !blockCanExitThroughDoor) {
                return null;
            }
            
            // For multi-layer blocks: slide to willExit position
            // Don't stop at intermediate positions where block would be partially outside
            if (exitingCells > 0) {
                const hasOuterLayer = block.innerBlockType >= 0 && 
                                      block.innerBlockType <= 9 && 
                                      !block.outerLayerDestroyed;
                if (hasOuterLayer && exitingCells < exitThreshold) {
                    // Not enough cells for willExit yet - need to slide further
                    // Save original position (last safe position on field)
                    const originalRow = block.gridRow;
                    const originalCol = block.gridCol;
                    
                    // Try sliding until willExit or blocked (max 10 steps)
                    let lastSafeRow = originalRow;
                    let lastSafeCol = originalCol;
                    
                    for (let slide = 0; slide < 10; slide++) {
                        // Move one step
            block.gridRow += dRow;
            block.gridCol += dCol;
                        
                        const slideCells = getBlockCells(block, state.gridHeight);
                        let slideExiting = 0, slideBlocked = 0, slideMovable = 0;
                        
                        // Check current position - are all cells on field?
                        let allCellsOnField = true;
                        for (const cell of slideCells) {
                            if (cell.row < 0 || cell.row >= state.gridHeight ||
                                cell.col < 0 || cell.col >= state.gridWidth) {
                                allCellsOnField = false;
                            }
                        }
                        
                        // Check NEXT step to see if we'd reach willExit
                        for (const cell of slideCells) {
                            const nr = cell.row + dRow;
                            const nc = cell.col + dCol;
                            
                            // Check if cell would be on door position
                            if (isDoorExit(newState, nr, nc, blockType, move.direction)) {
                                slideExiting++;
                                continue;
                            }
                            
                            // Check if cell would be out of bounds
                            if (nr < 0 || nr >= state.gridHeight || nc < 0 || nc >= state.gridWidth) {
                                if (door && canExitThroughDoorEdge(door, cell, nr, nc, move.direction)) {
                                    slideExiting++;
                                } else if (door) {
                                    const doorStartRow = door.startRow;
                                    const doorEndRow = door.startRow + door.partCount - 1;
                                    const doorStartCol = door.startCol;
                                    const doorEndCol = door.startCol + door.partCount - 1;
                                    
                                    let passedThroughDoor = false;
                                    if (door.edge === 'right' && move.direction === 'RIGHT') {
                                        passedThroughDoor = cell.row >= doorStartRow && cell.row <= doorEndRow;
                                    } else if (door.edge === 'left' && move.direction === 'LEFT') {
                                        passedThroughDoor = cell.row >= doorStartRow && cell.row <= doorEndRow;
                                    } else if (door.edge === 'top' && move.direction === 'UP') {
                                        passedThroughDoor = cell.col >= doorStartCol && cell.col <= doorEndCol;
                                    } else if (door.edge === 'bottom' && move.direction === 'DOWN') {
                                        passedThroughDoor = cell.col >= doorStartCol && cell.col <= doorEndCol;
                                    }
                                    
                                    if (passedThroughDoor) {
                                        slideExiting++;
                                    } else {
                                        slideBlocked++;
                                    }
                                } else {
                                    slideBlocked++;
                                }
                                continue;
                            }
                            if (hasCollision(newState, move.blockIndex, nr, nc)) {
                                slideBlocked++;
                                continue;
                            }
                            slideMovable++;
                        }
                        
                        // Update last safe position (where all cells are on field)
                        if (allCellsOnField) {
                            lastSafeRow = block.gridRow;
                            lastSafeCol = block.gridCol;
                        }
                        
                        // Check if we reached willExit (50%+ cells would exit on next step)
                        if (slideExiting >= exitThreshold) {
                            // Found willExit position - remove layer
                            // Return block to last safe position ON THE FIELD
                            block.gridRow = lastSafeRow;
                            block.gridCol = lastSafeCol;
                            block.outerLayerDestroyed = true;
                            return newState;
                        }
                        
                        // Can't continue sliding - either blocked or no cells exiting
                        if (slideBlocked > 0 || slideExiting === 0) {
                            return null; // Stuck
                        }
                    }
                    return null; // Max slides reached
                }
            }
            
            block.gridRow += dRow;
            block.gridCol += dCol;
            return newState;
        }
        
        // Cannot move
        return null;
    }

    /**
     * Calculate heuristic: sum of distances of all blocks to their doors
     */
    function heuristic(state) {
        let totalDistance = 0;
        let multiLayerPenalty = 0;
        
        for (let i = 0; i < state.blocks.length; i++) {
            if (state.exitedBlocks.has(i)) continue;
            
            const block = state.blocks[i];
            
            // Multi-layer blocks with outer layer still intact need 2 moves (remove layer + exit)
            // Add penalty to encourage exploring states where layers are already removed
            const hasOuterLayer = block.innerBlockType >= 0 && 
                                  block.innerBlockType <= 9 && 
                                  !block.outerLayerDestroyed;
            if (hasOuterLayer) {
                multiLayerPenalty += 1; // Each intact layer adds 1 to heuristic
            }
            
            const blockType = block.outerLayerDestroyed ? block.innerBlockType : block.blockType;
            const door = getDoorForType(state, blockType);
            if (!door) continue;
            
            const cells = getBlockCells(block, state.gridHeight);
            
            // Calculate minimum distance to door
            let minDist = Infinity;
                                            for (const cell of cells) {
                let dist = 0;
                if (door.edge === 'top') {
                    dist = cell.row + 1; // Distance to row -1
                    // Add horizontal distance if not aligned
                    const doorCols = new Set();
                    for (let c = door.startCol; c < door.startCol + door.partCount; c++) doorCols.add(c);
                    if (!doorCols.has(cell.col)) {
                        dist += Math.min(Math.abs(cell.col - door.startCol), Math.abs(cell.col - (door.startCol + door.partCount - 1)));
                    }
                } else if (door.edge === 'bottom') {
                    dist = state.gridHeight - cell.row;
                    const doorCols = new Set();
                    for (let c = door.startCol; c < door.startCol + door.partCount; c++) doorCols.add(c);
                    if (!doorCols.has(cell.col)) {
                        dist += Math.min(Math.abs(cell.col - door.startCol), Math.abs(cell.col - (door.startCol + door.partCount - 1)));
                    }
                } else if (door.edge === 'left') {
                    dist = cell.col + 1;
                    const doorRows = new Set();
                    for (let r = door.startRow; r < door.startRow + door.partCount; r++) doorRows.add(r);
                    if (!doorRows.has(cell.row)) {
                        dist += Math.min(Math.abs(cell.row - door.startRow), Math.abs(cell.row - (door.startRow + door.partCount - 1)));
                    }
                } else if (door.edge === 'right') {
                    dist = state.gridWidth - cell.col;
                    const doorRows = new Set();
                    for (let r = door.startRow; r < door.startRow + door.partCount; r++) doorRows.add(r);
                    if (!doorRows.has(cell.row)) {
                        dist += Math.min(Math.abs(cell.row - door.startRow), Math.abs(cell.row - (door.startRow + door.partCount - 1)));
                    }
                }
                minDist = Math.min(minDist, dist);
            }
            totalDistance += minDist === Infinity ? 10 : minDist;
        }
        return totalDistance + multiLayerPenalty;
    }
    
    /**
     * Get all valid step counts for a block moving in a direction
     * Returns array of step counts, including stops at doors
     */
    function getValidStepCounts(state, blockIndex, direction) {
        const validSteps = [];
        let testState = cloneState(state);
        let steps = 0;
        const originalBlock = state.blocks[blockIndex];
        const hadOuterLayer = originalBlock.innerBlockType >= 0 && 
                              originalBlock.innerBlockType <= 9 && 
                              !originalBlock.outerLayerDestroyed;
        
        // Debug: log for Block 0 (plus)
        const isBlock0 = blockIndex === 0 && originalBlock.blockGroupType === 6;
        
        while (steps < 20) { // Safety limit
            const newState = applyMove(testState, { blockIndex, direction });
            if (!newState) {
                if (DEBUG && isBlock0) console.log(`[getValidStepCounts] Block 0 dir=${direction}: stopped at step ${steps} (applyMove returned null)`);
                break;
            }
            steps++;
            
            // Block exited - this is a valid stop
            if (newState.exitedBlocks.has(blockIndex)) {
                validSteps.push(steps);
                break;
            }
            
            // Check if outer layer was just removed (multi-layer block hit door)
            const newBlock = newState.blocks[blockIndex];
            if (hadOuterLayer && newBlock.outerLayerDestroyed && !testState.blocks[blockIndex].outerLayerDestroyed) {
                // Layer was removed on this step - valid stop!
                validSteps.push(steps);
                // Don't break - block might need to continue moving after layer removal
            }
            
            // Check if block is now aligned with a door (can exit on next move)
            // For multi-layer blocks with intact outer layer moving toward outer layer's door:
            // DON'T add "aligned" as valid stop - the swipe continues until layer is removed
            const currentHasOuterLayer = newBlock.innerBlockType >= 0 && 
                                         newBlock.innerBlockType <= 9 && 
                                         !newBlock.outerLayerDestroyed;
            const blockType = newBlock.outerLayerDestroyed ? newBlock.innerBlockType : newBlock.blockType;
            const doors = getAllDoorsForType(newState, blockType);
            
            for (const door of doors) {
                if (canBlockExitThroughDoor(newState, newBlock, door, direction)) {
                    // Check if this is outer layer's door and swipe direction matches door
                    const doorDirection = { top: 'UP', bottom: 'DOWN', left: 'LEFT', right: 'RIGHT' }[door.edge];
                    const isMovingTowardOuterDoor = currentHasOuterLayer && doorDirection === direction;
                    
                    if (isMovingTowardOuterDoor) {
                        // Multi-layer block moving toward its outer door - don't stop at "aligned"
                        // The swipe will continue and remove layer on next step
                        continue;
                    }
                    
                    // Block is aligned with door - add as valid stop
                    if (!validSteps.includes(steps)) {
                        validSteps.push(steps);
                    }
                }
            }
            
            testState = newState;
        }
        
        // Always include max steps if not already added
        if (steps > 0 && !validSteps.includes(steps)) {
            validSteps.push(steps);
        }
        
        if (DEBUG && isBlock0) console.log(`[getValidStepCounts] Block 0 dir=${direction}: validSteps=[${validSteps.join(',')}], exitedBlocks=[${[...state.exitedBlocks].join(',')}]`);
        
        return validSteps.length > 0 ? validSteps : [1]; // At least 1 step
    }

    /**
     * Heuristic solver: prioritizes blocks with direct paths
     */
    function solve(level, maxStatesLimit = null) {
        const startTime = performance.now();
        let state = createState(level);
        const path = [];
        let statesExplored = 0;
        
        // Phase 1: Greedy - exit all blocks with direct paths
        let progress = true;
        while (progress && state.exitedBlocks.size < state.blocks.length) {
            progress = false;
            
            // Find all blocks with direct paths
            const directPaths = [];
            for (let i = 0; i < state.blocks.length; i++) {
                const dp = hasDirectPath(state, i);
                if (dp) {
                    directPaths.push({ blockIndex: i, ...dp });
                }
            }
            
            if (directPaths.length > 0) {
                // Sort by steps to exit (shortest first)
                directPaths.sort((a, b) => a.stepsToExit - b.stepsToExit);
                const chosen = directPaths[0];
                
                // Apply all moves to exit this block - count as 1 swipe
                let actualSteps = 0;
                for (let step = 0; step < chosen.stepsToExit; step++) {
                    const newState = applyMove(state, { blockIndex: chosen.blockIndex, direction: chosen.direction });
                    if (newState) {
                        state = newState;
                        actualSteps++;
                        statesExplored++;
                                    } else {
                        break;
                    }
                }
                if (actualSteps > 0) {
                    // 1 swipe = 1 move, regardless of cells traveled
                    path.push({ blockIndex: chosen.blockIndex, direction: chosen.direction, steps: actualSteps });
                    progress = true;
                }
            }
        }
        
        // Phase 2: If not all blocks exited, use A* for remaining
        if (state.exitedBlocks.size < state.blocks.length) {
            const limit = maxStatesLimit || maxStates;
            
            // Priority queue: lower score = higher priority
            // Score = path length + heuristic (distance to doors)
            const queue = [{state, path: [...path], score: heuristic(state)}];
            const visited = new Set([stateKey(state)]);
            
            // Track best partial solution
            let maxExitedBlocks = state.exitedBlocks.size;
            let maxExitedPath = [...path];
            
            let iterations = 0;
            while (queue.length > 0 && statesExplored < limit) {
                // A*: sort queue by score (lowest first) - do it periodically for performance
                if (iterations % 100 === 0) {
                    queue.sort((a, b) => a.score - b.score);
                }
                
                const current = queue.shift();
                statesExplored++;
                iterations++;
                
                // Debug: log when exploring state with Block 0's outer layer destroyed
                if (current.state.blocks[0].outerLayerDestroyed && !current.state.exitedBlocks.has(0)) {
                    DEBUG && console.log(`[A*] Exploring state with Block 0 outerLayerDestroyed=true, pos=(${current.state.blocks[0].gridRow},${current.state.blocks[0].gridCol}), iteration=${iterations}`);
                }
                
                if (current.state.exitedBlocks.size === current.state.blocks.length) {
                    return {
                        isSolvable: true,
                        minMoves: current.path.length,
                        solution: current.path,
                        statesExplored,
                        searchTime: performance.now() - startTime
                    };
                }
                
                const moves = getPossibleMoves(current.state);
                
                let addedCount = 0;
            for (const move of moves) {
                    // Get all valid step counts (including stops at doors)
                    const validStepCounts = getValidStepCounts(current.state, move.blockIndex, move.direction);
                    
                    for (const numSteps of validStepCounts) {
                        // Apply steps
                        let testState = current.state;
                        let actualSteps = 0;
                        
                        for (let s = 0; s < numSteps; s++) {
                            const newState = applyMove(testState, move);
                            if (!newState) break;
                            testState = newState;
                            actualSteps++;
                            if (newState.exitedBlocks.has(move.blockIndex)) break; // Block exited
                        }
                        
                        if (actualSteps === 0) continue;
                        
                        const key = stateKey(testState);
                if (!visited.has(key)) {
                    visited.add(key);
                            // Count as 1 move regardless of steps, but store steps for visualization
                            const moveWithSteps = { ...move, steps: actualSteps };
                            const newPath = [...current.path, moveWithSteps];
                            const newScore = newPath.length + heuristic(testState);
                            queue.push({state: testState, path: newPath, score: newScore});
                            addedCount++;
                            
                            // Debug: log when Block 0's outer layer was just destroyed
                            if (move.blockIndex === 0 && testState.blocks[0].outerLayerDestroyed && !current.state.blocks[0].outerLayerDestroyed) {
                                DEBUG && console.log(`[A*] Block 0 outer layer destroyed! Added to queue. Key: ${key}, Score: ${newScore}, Path length: ${newPath.length}`);
                            }
                            
                            // Track best partial solution
                            if (testState.exitedBlocks.size > maxExitedBlocks) {
                                maxExitedBlocks = testState.exitedBlocks.size;
                                maxExitedPath = newPath;
                            }
                        }
                    }
                }
            }
        
        return {
            isSolvable: false,
            statesExplored,
            searchTime: performance.now() - startTime,
                error: statesExplored >= limit ? 'Max states reached' : 'No solution',
                partialSolution: maxExitedPath.length > 0 ? maxExitedPath : null,
                maxExitedBlocks
            };
        }
        
        return {
            isSolvable: true,
            minMoves: path.length,
            solution: path,
            statesExplored,
            searchTime: performance.now() - startTime
        };
    }

    // ============ RENDERING ============
    function render() {
        if (!gameState) return;
        
        const cellSize = 50;
        const padding = 60;
        const width = gameState.gridWidth * cellSize + padding * 2;
        const height = gameState.gridHeight * cellSize + padding * 2;
        
        canvas.width = width;
        canvas.height = height;
        
        ctx.fillStyle = '#2a2a4a';
        ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = '#3a3a5a';
        ctx.lineWidth = 1;
        for (let r = 0; r <= gameState.gridHeight; r++) {
            ctx.beginPath();
            ctx.moveTo(padding, padding + r * cellSize);
            ctx.lineTo(padding + gameState.gridWidth * cellSize, padding + r * cellSize);
            ctx.stroke();
        }
        for (let c = 0; c <= gameState.gridWidth; c++) {
            ctx.beginPath();
            ctx.moveTo(padding + c * cellSize, padding);
            ctx.lineTo(padding + c * cellSize, padding + gameState.gridHeight * cellSize);
            ctx.stroke();
        }
        
        // Draw hidden cells
        ctx.fillStyle = '#1a1a2a';
        gameState.hiddenCells.forEach(h => {
            ctx.fillRect(
                padding + h.col * cellSize + 1,
                padding + h.row * cellSize + 1,
                cellSize - 2,
                cellSize - 2
            );
        });
        
        // Draw doors
        gameState.doors.forEach(door => {
            ctx.fillStyle = COLORS[door.blockType] || '#888';
            const cells = getDoorCells(door);
            cells.forEach(cell => {
                let x, y, w, h;
                if (door.edge === 'top') {
                    x = padding + cell.col * cellSize;
                    y = padding - 15;
                    w = cellSize;
                    h = 15;
                } else if (door.edge === 'bottom') {
                    x = padding + cell.col * cellSize;
                    y = padding + gameState.gridHeight * cellSize;
                    w = cellSize;
                    h = 15;
                } else if (door.edge === 'left') {
                    x = padding - 15;
                    y = padding + cell.row * cellSize;
                    w = 15;
                    h = cellSize;
                } else {
                    x = padding + gameState.gridWidth * cellSize;
                    y = padding + cell.row * cellSize;
                    w = 15;
                    h = cellSize;
                }
                ctx.fillRect(x, y, w, h);
            });
        });
        
        // Draw blocks
        gameState.blocks.forEach((block, i) => {
            if (gameState.exitedBlocks.has(i)) return;
            
            const cells = getBlockCells(block, gameState.gridHeight);
            // Multi-layer block: has innerBlockType that is different from blockType
            const isMultiLayer = block.innerBlockType >= 0 && 
                                 block.innerBlockType <= 9 && 
                                 block.innerBlockType !== block.blockType;
            const outerColor = COLORS[block.blockType] || '#888';
            const innerColor = isMultiLayer ? (COLORS[block.innerBlockType] || '#888') : outerColor;
            
            // –î–ª—è multi-layer: –∑–∞–ª–∏–≤–∫–∞ = inner color, –æ–±–≤–æ–¥–∫–∞ = outer color (–ø–æ–∫–∏ —î)
            // –ü—ñ—Å–ª—è –∑–Ω—è—Ç—Ç—è –∑–æ–≤–Ω—ñ—à–Ω—å–æ–≥–æ —à–∞—Ä—É: —Ç—ñ–ª—å–∫–∏ inner color
            // –î–ª—è –∑–≤–∏—á–∞–π–Ω–æ–≥–æ: –∑–∞–ª–∏–≤–∫–∞ = blockType color
            const fillColor = isMultiLayer ? innerColor : outerColor;
            const borderColor = (isMultiLayer && !block.outerLayerDestroyed) ? outerColor : null;
            
            // Animation offset for this block
            let animOffsetX = 0;
            let animOffsetY = 0;
            if (isAnimating && animatingBlockIndex === i && prevBlockPositions) {
                const prev = prevBlockPositions;
                const deltaRow = block.gridRow - prev.row;
                const deltaCol = block.gridCol - prev.col;
                // Easing: ease-out cubic
                const t = 1 - Math.pow(1 - animationProgress, 3);
                // Offset is the remaining distance to travel (starts at full delta, ends at 0)
                animOffsetX = deltaCol * cellSize * (t - 1);
                animOffsetY = deltaRow * cellSize * (t - 1);
            }
            
            cells.forEach(cell => {
                const x = padding + cell.col * cellSize + 2 + animOffsetX;
                const y = padding + cell.row * cellSize + 2 + animOffsetY;
                const size = cellSize - 4;
                
                // Block body (fill color)
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.roundRect(x, y, size, size, 6);
                ctx.fill();
                
                // Multi-layer block: —Ç–æ–≤—Å—Ç–∞ –æ–±–≤–æ–¥–∫–∞ –∑–æ–≤–Ω—ñ—à–Ω—å–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
                if (borderColor) {
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 6; // –¢–æ–≤—Å—Ç–∞ –æ–±–≤–æ–¥–∫–∞ –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç—ñ
                    ctx.beginPath();
                    ctx.roundRect(x, y, size, size, 6);
                    ctx.stroke();
                }
                
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.roundRect(x + 3, y + 3, size - 6, size / 3, 4);
                ctx.fill();
                
                // Stud
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(x + size/2, y + size/2, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Ice overlay
                if ((block.iceCount || 0) > 0) {
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                    ctx.beginPath();
                    ctx.roundRect(x, y, size, size, 6);
                    ctx.fill();
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(block.iceCount, x + size/2, y + size/2 + 6);
                }
                
                // Movement arrows
                const moveDir = block.moveDirection ?? 2;
                if (moveDir === 0 || moveDir === 1) {
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(moveDir === 0 ? '‚Üî' : '‚Üï', x + size/2, y + size - 5);
                }
            });
        });
        
        // Draw exiting block (animating out through door)
        if (isAnimating && exitingBlockData && prevBlockPositions) {
            const block = exitingBlockData.block;
            const cells = getBlockCells(block, gameState.gridHeight);
            
            const isMultiLayer = block.innerBlockType >= 0 && 
                                 block.innerBlockType <= 9 && 
                                 block.innerBlockType !== block.blockType;
            const outerColor = COLORS[block.blockType] || '#888';
            const innerColor = isMultiLayer ? (COLORS[block.innerBlockType] || '#888') : outerColor;
            const fillColor = isMultiLayer ? innerColor : outerColor;
            const borderColor = (isMultiLayer && !block.outerLayerDestroyed) ? outerColor : null;
            
            // Calculate movement direction
            const [dRow, dCol] = DELTAS[exitingBlockData.direction];
            // Easing: ease-out cubic
            const t = 1 - Math.pow(1 - animationProgress, 3);
            // Move 1.5 cells out (enough to exit completely)
            const exitDistance = cellSize * 1.5;
            const animOffsetX = dCol * exitDistance * t;
            const animOffsetY = dRow * exitDistance * t;
            
            // Fade out as block exits
            const alpha = 1 - animationProgress;
            
            cells.forEach(cell => {
                const x = padding + cell.col * cellSize + 2 + animOffsetX;
                const y = padding + cell.row * cellSize + 2 + animOffsetY;
                const size = cellSize - 4;
                
                ctx.globalAlpha = alpha;
                
                // Block body
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.roundRect(x, y, size, size, 6);
                ctx.fill();
                
                // Border for multi-layer
                if (borderColor) {
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.roundRect(x, y, size, size, 6);
                    ctx.stroke();
                }
                
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.roundRect(x + 3, y + 3, size - 6, size / 3, 4);
                ctx.fill();
                
                // Stud
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(x + size/2, y + size/2, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            });
        }
        
        // Draw level info
        ctx.fillStyle = '#888';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Level ${currentLevel?.id || '-'} | ${gameState.gridWidth}x${gameState.gridHeight}`, 10, 20);
        
        if (solution) {
            ctx.fillText(`Step: ${currentStep + 1}/${solution.length}`, 10, height - 10);
        }
    }

    // ============ UI ACTIONS ============
    function resetLevel(keepSolution = false) {
        if (!currentLevel) return;
        gameState = createState(currentLevel);
        if (!keepSolution) {
            solution = null;
            document.getElementById('solutionSteps').innerHTML = 
                '<p style="color: var(--text-muted);">Click "Solve Level" to find solution</p>';
        }
        currentStep = -1;
        stopAutoPlay();
        render();
    }

    let currentMaxStates = null; // Track current limit for Continue Anyway
    
    function solveCurrent(customLimit = null) {
        if (!currentLevel) return;
        
        const limitToUse = customLimit || maxStates;
        currentMaxStates = limitToUse;
        
        // Hide Continue Anyway button
        document.getElementById('continueAnywayContainer').style.display = 'none';
        
        document.getElementById('solveBtn').disabled = true;
        document.getElementById('solveBtn').textContent = 'Solving...';
        
        log(`üîç Analyzing Level ${currentLevel.id}...`);
        log(`üìä Algorithm: BFS (Breadth-First Search)`);
        setTimeout(() => {
            const result = solve(currentLevel, limitToUse);
            analysisResults.set(currentLevel.id, result);
            displayResult(result);
            renderLevelList();
            
            if (result.isSolvable) {
                log(`‚úÖ Level ${currentLevel.id}: Solvable in ${result.minMoves} moves`);
                solution = result.solution;
                currentStep = -1;
                resetLevel(true); // Keep solution visible
            } else {
                log(`‚ùå Level ${currentLevel.id}: ${result.error}`);
                
                // Show partial solution if available
                if (result.partialSolution && result.partialSolution.length > 0) {
                    log(`üìã Partial solution: ${result.partialSolution.length} moves, ${result.maxExitedBlocks || 0} blocks exited`);
                    solution = result.partialSolution;
                    currentStep = -1;
                    resetLevel(true);
                }
                
                // Show Continue Anyway button if max states reached
                if (result.error === 'Max states reached') {
                    document.getElementById('continueAnywayContainer').style.display = 'block';
                }
            }
            
            document.getElementById('solveBtn').disabled = false;
            document.getElementById('solveBtn').textContent = 'Solve Level';
            enableExportButtons();
        }, 50);
    }
    
    function continueWithHigherLimit() {
        if (!currentLevel) return;
        const newLimit = currentMaxStates ? currentMaxStates * 2 : maxStates * 2;
        log(`‚ö° Continuing with higher limit: ${newLimit.toLocaleString()} states`);
        solveCurrent(newLimit);
    }

    function displayResult(result) {
        // Status
        document.getElementById('statusValue').textContent = result.isSolvable ? 'SOLVABLE' : 'UNSOLVABLE';
        document.getElementById('statusValue').className = 'stat-value ' + (result.isSolvable ? 'success' : 'alert-error');
        
        // Moves
        document.getElementById('movesValue').textContent = result.minMoves ?? '-';
        
        // States with alert
        const statesEl = document.getElementById('statesValue');
        statesEl.textContent = result.statesExplored.toLocaleString();
        if (result.statesExplored >= ALERTS.maxStatesError) {
            statesEl.className = 'stat-value alert-error';
        } else if (result.statesExplored >= ALERTS.maxStatesWarning) {
            statesEl.className = 'stat-value alert-warning';
        } else {
            statesEl.className = 'stat-value';
        }
        
        // Time with alert
        const timeEl = document.getElementById('timeValue');
        timeEl.textContent = `${result.searchTime.toFixed(0)}ms`;
        if (result.searchTime >= ALERTS.maxTimeError) {
            timeEl.className = 'stat-value alert-error';
        } else if (result.searchTime >= ALERTS.maxTimeWarning) {
            timeEl.className = 'stat-value alert-warning';
        } else {
            timeEl.className = 'stat-value';
        }
        
        if (result.isSolvable && result.solution) {
            solution = result.solution;
            document.getElementById('solutionSteps').innerHTML = result.solution.map((move, i) => `
                <div class="step ${i === currentStep ? 'active' : ''}" onclick="goToStep(${i})">
                    <span class="step-num">${i + 1}</span>
                    Block ${move.blockIndex} ‚Üí ${move.direction}${move.steps > 1 ? ` (√ó${move.steps})` : ''}
                </div>
            `).join('');
        }
    }

    function clearStats() {
        document.getElementById('statusValue').textContent = '-';
        document.getElementById('statusValue').className = 'stat-value';
        document.getElementById('movesValue').textContent = '-';
        document.getElementById('statesValue').textContent = '-';
        document.getElementById('timeValue').textContent = '-';
    }

    function playStep(delta) {
        if (!solution || solution.length === 0) return;
        if (isAnimating) return; // Don't interrupt animation
        
        const newStep = currentStep + delta;
        if (newStep < -1 || newStep >= solution.length) return;
        
        if (delta === 1 && currentStep >= -1) {
            // Moving forward - animate the step
            animateToStep(newStep);
        } else {
            // Moving backward or jumping - instant
        goToStep(newStep);
        }
    }

    function goToStep(step) {
        if (!solution) return;
        
        // Stop any running animation
        isAnimating = false;
        
        // Reset and replay to step
        gameState = createState(currentLevel);
        for (let i = 0; i <= step; i++) {
            const move = solution[i];
            const steps = move.steps || 1; // Support multi-step moves
            for (let s = 0; s < steps; s++) {
                gameState = applyMove(gameState, move) || gameState;
            }
        }
        
        // Debug: log position of all blocks after this step
        DEBUG && console.log(`[goToStep ${step + 1}] Block positions:`);
        gameState.blocks.forEach((block, idx) => {
            if (!gameState.exitedBlocks.has(idx)) {
                const cells = getBlockCells(block, gameState.gridHeight);
                const uniqueRows = [...new Set(cells.map(c => c.row))].sort((a,b) => a-b);
                const uniqueCols = [...new Set(cells.map(c => c.col))].sort((a,b) => a-b);
                console.log(`  Block ${idx}: type=${block.blockType} gt=${block.blockGroupType} at (${block.gridRow},${block.gridCol}) rows=[${uniqueRows}] cols=[${uniqueCols}] outerDestroyed=${block.outerLayerDestroyed || false}`);
            }
        });
        
        currentStep = step;
        render();
        
        // Update step highlighting
        document.querySelectorAll('.step').forEach((el, i) => {
            el.className = 'step' + (i === step ? ' active' : '');
        });
    }
    
    function animateToStep(targetStep, onComplete) {
        if (!solution || targetStep < 0 || targetStep >= solution.length) return;
        
        const move = solution[targetStep];
        const moveSteps = move.steps || 1;
        
        // Get state before this move
        let stateBeforeMove = createState(currentLevel);
        for (let i = 0; i < targetStep; i++) {
            const m = solution[i];
            const s = m.steps || 1;
            for (let j = 0; j < s; j++) {
                stateBeforeMove = applyMove(stateBeforeMove, m) || stateBeforeMove;
            }
        }
        
        // Save previous position of the moving block
        const block = stateBeforeMove.blocks[move.blockIndex];
        prevBlockPositions = { row: block.gridRow, col: block.gridCol };
        animatingBlockIndex = move.blockIndex;
        
        // Check if block will exit (save block data for exit animation)
        const wasExited = stateBeforeMove.exitedBlocks.has(move.blockIndex);
        
        // Apply move to get final state
        gameState = stateBeforeMove;
        for (let s = 0; s < moveSteps; s++) {
            gameState = applyMove(gameState, move) || gameState;
        }
        
        const willExit = gameState.exitedBlocks.has(move.blockIndex) && !wasExited;
        
        // If block exits, save its data for animation
        if (willExit) {
            exitingBlockData = {
                index: move.blockIndex,
                block: { ...block }, // Copy block data before exit
                direction: move.direction
            };
        } else {
            exitingBlockData = null;
        }
        
        currentStep = targetStep;
        
        // Update step highlighting immediately
        document.querySelectorAll('.step').forEach((el, i) => {
            el.className = 'step' + (i === targetStep ? ' active' : '');
        });
        
        // Start animation
        isAnimating = true;
        animationProgress = 0;
        animationStartTime = performance.now();
        animationCallback = onComplete;
        
        requestAnimationFrame(animationFrame);
    }
    
    function animationFrame(timestamp) {
        if (!isAnimating) return;
        
        const elapsed = timestamp - animationStartTime;
        animationProgress = Math.min(elapsed / animationDuration, 1);
        
        render();
        
        if (animationProgress < 1) {
            requestAnimationFrame(animationFrame);
        } else {
            // Animation complete
            isAnimating = false;
            prevBlockPositions = null;
            animatingBlockIndex = -1;
            exitingBlockData = null;
            
            if (animationCallback) {
                const cb = animationCallback;
                animationCallback = null;
                cb();
            }
        }
    }

    function toggleAutoPlay() {
        if (isPlaying) {
            stopAutoPlay();
        } else {
            startAutoPlay();
        }
    }

    function startAutoPlay() {
        if (!solution || solution.length === 0) return;
        
        isPlaying = true;
        document.getElementById('playBtn').textContent = '‚è∏ Pause';
        
        autoPlayNextStep();
    }
    
    function autoPlayNextStep() {
        if (!isPlaying) return;
        
            if (currentStep >= solution.length - 1) {
                stopAutoPlay();
                return;
            }
        
        const speed = parseInt(document.getElementById('speedSlider').value);
        const pauseBetweenMoves = Math.max(50, speed - animationDuration);
        
        // Animate to next step, then schedule next
        animateToStep(currentStep + 1, () => {
            if (isPlaying) {
                setTimeout(autoPlayNextStep, pauseBetweenMoves);
            }
        });
    }

    function stopAutoPlay() {
        isPlaying = false;
        document.getElementById('playBtn').textContent = '‚ñ∂ Play';
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
    }

    async function analyzeAllLevels() {
        const btn = document.getElementById('analyzeAllBtn');
        btn.disabled = true;
        btn.textContent = 'Analyzing...';
        
        const batchStartTime = Date.now();
        const results = [];
        const progressBar = document.getElementById('analysisProgress');
        log(`üìä Starting batch analysis of ${levels.length} levels...`);
        log(`üìä Algorithm: BFS (Breadth-First Search)`);
        
        for (let i = 0; i < levels.length; i++) {
            const level = levels[i];
            const result = solve(level);
            result.levelId = level.id;
            results.push(result);
            analysisResults.set(level.id, result);
            
            progressBar.style.width = `${((i + 1) / levels.length) * 100}%`;
            renderLevelList();
            
            // Update batch results
            document.getElementById('batchResults').innerHTML = results.map(r => `
                <div class="batch-item ${r.isSolvable ? 'solved' : 'unsolved'}">
                    <span>Level ${r.levelId}</span>
                    <span>${r.isSolvable ? `${r.minMoves} moves` : 'FAIL'}</span>
                </div>
            `).join('');
            
            await new Promise(r => setTimeout(r, 10));
        }
        
        const solved = results.filter(r => r.isSolvable).length;
        const batchTime = ((Date.now() - batchStartTime) / 1000).toFixed(1);
        btn.textContent = `Done: ${solved}/${levels.length}`;
        btn.disabled = false;
        enableExportButtons();
        log(`üìä Batch complete: ${solved}/${levels.length} solvable in ${batchTime}s`);
        
        setTimeout(() => {
            btn.textContent = 'Analyze All';
        }, 3000);
    }

    // ============ INFO LOG ============
    function log(message) {
        const logEl = document.getElementById('infoLog');
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `[${time}] ${message}<br>` + logEl.innerHTML;
        // Keep only last 10 messages
        const lines = logEl.innerHTML.split('<br>');
        if (lines.length > 10) {
            logEl.innerHTML = lines.slice(0, 10).join('<br>');
        }
    }

    // ============ SETTINGS ============
    let maxStates = 50000;
    
    function toggleSettings() {
        const panel = document.getElementById('settingsPanel');
        const arrow = document.getElementById('settingsArrow');
        panel.classList.toggle('open');
        arrow.textContent = panel.classList.contains('open') ? '‚ñ≤' : '‚ñº';
    }
    
    function updateSettings() {
        maxStates = parseInt(document.getElementById('maxStatesInput').value) || 50000;
        ALERTS.maxStatesWarning = parseInt(document.getElementById('warnStatesInput').value) || 30000;
        ALERTS.maxTimeWarning = parseInt(document.getElementById('warnTimeInput').value) || 30000;
        ALERTS.maxStatesError = maxStates;
    }

    // ============ EXPORT FUNCTIONS ============
    function downloadFile(filename, content, type = 'text/plain') {
        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }
    
    function exportJSON() {
        if (analysisResults.size === 0) return;
        
        const results = Array.from(analysisResults.entries()).map(([id, r]) => ({
            levelId: id,
            solvable: r.isSolvable,
            minMoves: r.minMoves || null,
            statesExplored: r.statesExplored,
            searchTimeMs: Math.round(r.searchTime),
            error: r.error || null,
            solution: r.solution?.map(m => ({
                blockIndex: m.blockIndex,
                direction: m.direction
            })) || null
        }));
        
        const output = {
            version: '1.1.1',
            timestamp: new Date().toISOString(),
            source: currentSource.toUpperCase(),
            levels: results,
            summary: {
                total: results.length,
                solvable: results.filter(r => r.solvable).length,
                unsolvable: results.filter(r => !r.solvable).length,
                averageMoves: results.filter(r => r.solvable).length > 0 
                    ? (results.filter(r => r.solvable).reduce((sum, r) => sum + r.minMoves, 0) / results.filter(r => r.solvable).length).toFixed(1)
                    : 0
            }
        };
        
        downloadFile(`brute_force_results_${Date.now()}.json`, JSON.stringify(output, null, 2), 'application/json');
        log('üìÑ Exported results to JSON');
    }
    
    function exportMarkdown() {
        if (analysisResults.size === 0) return;
        
        const results = Array.from(analysisResults.entries()).map(([id, r]) => ({
            id, ...r
        }));
        
        const solved = results.filter(r => r.isSolvable).length;
        const avgMoves = results.filter(r => r.isSolvable).length > 0
            ? (results.filter(r => r.isSolvable).reduce((sum, r) => sum + r.minMoves, 0) / solved).toFixed(1)
            : 0;
        
        let md = `# Brute-Force Analysis Results\n\n`;
        md += `**Generated:** ${new Date().toLocaleString()}\n`;
        md += `**Source:** ${currentSource.toUpperCase()}\n`;
        md += `**Version:** v1.8.20\n\n`;
        md += `## Summary\n\n`;
        md += `- **Total Levels:** ${results.length}\n`;
        md += `- **Solvable:** ${solved} ‚úÖ\n`;
        md += `- **Unsolvable:** ${results.length - solved} ‚ùå\n`;
        md += `- **Average Moves:** ${avgMoves}\n\n`;
        md += `## Results\n\n`;
        md += `| Level | Status | Min Moves | States | Time (ms) | Error |\n`;
        md += `|-------|--------|-----------|--------|-----------|-------|\n`;
        
        results.forEach(r => {
            const status = r.isSolvable ? '‚úÖ OK' : '‚ùå FAIL';
            const moves = r.minMoves ?? '-';
            const states = r.statesExplored.toLocaleString();
            const time = Math.round(r.searchTime);
            const error = r.error || '-';
            md += `| ${r.id} | ${status} | ${moves} | ${states} | ${time} | ${error} |\n`;
        });
        
        downloadFile(`brute_force_results_${Date.now()}.md`, md, 'text/markdown');
        log('üìù Exported results to Markdown');
    }
    
    function enableExportButtons() {
        document.getElementById('exportJSONBtn').disabled = false;
        document.getElementById('exportMDBtn').disabled = false;
        document.getElementById('exportHTMLBtn').disabled = false;
        document.getElementById('viewStatsBtn').disabled = false;
        document.getElementById('saveToLevelBtn').disabled = false;
    }
    
    function viewFullStats() {
        if (analysisResults.size === 0) return;
        
        const results = Array.from(analysisResults.entries()).map(([id, r]) => ({
            id, ...r
        }));
        
        const solved = results.filter(r => r.isSolvable).length;
        const avgMoves = results.filter(r => r.isSolvable).length > 0
            ? (results.filter(r => r.isSolvable).reduce((sum, r) => sum + r.minMoves, 0) / solved).toFixed(1)
            : 0;
        const avgStates = (results.reduce((sum, r) => sum + r.statesExplored, 0) / results.length).toFixed(0);
        const avgTime = (results.reduce((sum, r) => sum + r.searchTime, 0) / results.length).toFixed(0);
        
        // Create popup window
        const popup = window.open('', 'BruteForceStats', 'width=800,height=600');
        popup.document.write(`<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Brute-Force Statistics</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #e94560; margin-bottom: 5px; }
        .subtitle { color: #888; margin-bottom: 20px; }
        .summary { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; }
        .stat-box { background: #16213e; padding: 15px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 2rem; font-weight: bold; color: #e94560; }
        .stat-label { color: #888; font-size: 0.9rem; }
        .ok { color: #4ade80; }
        .fail { color: #ef4444; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #0f3460; }
        th { background: #0f3460; position: sticky; top: 0; }
        .table-container { max-height: 350px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>üìä Brute-Force Statistics</h1>
    <p class="subtitle">Generated: ${new Date().toLocaleString()} | Source: ${currentSource.toUpperCase()} | Algorithm: BFS</p>
    <div style="margin-bottom: 20px;">
        <button onclick="window.opener.exportHTML(); window.close();" style="padding: 10px 20px; background: #4ade80; color: #111; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
            üíæ Save Stat to HTML
        </button>
        <button onclick="window.close();" style="padding: 10px 20px; margin-left: 10px; background: #0f3460; color: #eee; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
            ‚úï Close
        </button>
    </div>
    <div class="summary">
        <div class="stat-box">
            <div class="stat-value">${results.length}</div>
            <div class="stat-label">Total Levels</div>
        </div>
        <div class="stat-box">
            <div class="stat-value ok">${solved}</div>
            <div class="stat-label">Solvable</div>
        </div>
        <div class="stat-box">
            <div class="stat-value fail">${results.length - solved}</div>
            <div class="stat-label">Unsolvable</div>
        </div>
        <div class="stat-box">
            <div class="stat-value">${avgMoves}</div>
            <div class="stat-label">Avg Moves</div>
        </div>
    </div>
    
    <div class="summary">
        <div class="stat-box">
            <div class="stat-value">${parseInt(avgStates).toLocaleString()}</div>
            <div class="stat-label">Avg States</div>
        </div>
        <div class="stat-box">
            <div class="stat-value">${avgTime}ms</div>
            <div class="stat-label">Avg Time</div>
        </div>
        <div class="stat-box">
            <div class="stat-value">${((solved / results.length) * 100).toFixed(1)}%</div>
            <div class="stat-label">Success Rate</div>
        </div>
        <div class="stat-box">
            <div class="stat-value">${maxStates.toLocaleString()}</div>
            <div class="stat-label">Max States Limit</div>
        </div>
    </div>
    
    <h2>üìã All Results</h2>
    <div class="table-container">
        <table>
            <tr>
                <th>Level</th>
                <th>Status</th>
                <th>Moves</th>
                <th>States</th>
                <th>Time</th>
            </tr>
            ${results.map(r => `
            <tr>
                <td>Level ${r.id}</td>
                <td class="${r.isSolvable ? 'ok' : 'fail'}">${r.isSolvable ? '‚úÖ OK' : '‚ùå FAIL'}</td>
                <td>${r.minMoves ?? '-'}</td>
                <td>${r.statesExplored.toLocaleString()}</td>
                <td>${Math.round(r.searchTime)}ms</td>
            </tr>`).join('')}
        </table>
    </div>
</body>
</html>`);
        popup.document.close();
        log('üìä Opened stats in new window');
    }
    
    async function saveBruteForceStatsToLevelFile() {
        if (analysisResults.size === 0) {
            alert('No analysis results to save. Please analyze levels first.');
            return;
        }
        
        if (!confirm('This will save brute-force statistics directly to the level file structure. Continue?')) {
            return;
        }
        
        try {
            // Load current levels file
            const url = SOURCES[currentSource];
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load levels: HTTP ${response.status}`);
            
            const data = await response.json();
            const levelsData = data.levels || data;
            
            // Add bruteForceResult to each level that has analysis
            let updatedCount = 0;
            for (let i = 0; i < levelsData.length; i++) {
                const level = levelsData[i];
                const result = analysisResults.get(level.id);
                
                if (result) {
                    // Initialize metadata if not exists
                    if (!level.metadata) {
                        level.metadata = {};
                    }
                    
                    // Add bruteForceResult
                    level.metadata.bruteForceResult = {
                        solvable: result.isSolvable,
                        minMoves: result.minMoves || null,
                        statesExplored: result.statesExplored,
                        searchTimeMs: Math.round(result.searchTime),
                        error: result.error || null,
                        algorithm: 'BFS',
                        analyzedAt: new Date().toISOString(),
                        bruteForceVersion: '1.1.1',
                        gameEngineVersion: GAME_ENGINE_VERSION
                    };
                    
                    // Add solution if available
                    if (result.solution && result.solution.length > 0) {
                        level.metadata.bruteForceResult.solution = result.solution.map(m => ({
                            blockIndex: m.blockIndex,
                            direction: m.direction
                        }));
                    }
                    
                    updatedCount++;
                }
            }
            
            // Create output structure
            const output = {
                levels: levelsData,
                metadata: {
                    source: currentSource.toUpperCase(),
                    bruteForceVersion: '1.1.1',
                    gameEngineVersion: GAME_ENGINE_VERSION,
                    updatedAt: new Date().toISOString(),
                    levelsAnalyzed: updatedCount
                }
            };
            
            // Download the updated file
            const filename = `levels_with_bruteforce_${currentSource}_${Date.now()}.json`;
            downloadFile(filename, JSON.stringify(output, null, 2), 'application/json');
            
            log(`üíæ Saved brute-force stats to level file: ${updatedCount} levels updated`);
            alert(`Successfully saved brute-force statistics to ${updatedCount} level(s)!\n\nFile saved as: ${filename}`);
        } catch (e) {
            console.error('Failed to save to level file:', e);
            alert(`Error saving to level file: ${e.message}`);
            log(`‚ùå Failed to save to level file: ${e.message}`);
        }
    }
    
    function exportHTML() {
        if (analysisResults.size === 0) return;
        
        const results = Array.from(analysisResults.entries()).map(([id, r]) => ({
            id, ...r
        }));
        
        const solved = results.filter(r => r.isSolvable).length;
        const avgMoves = results.filter(r => r.isSolvable).length > 0
            ? (results.filter(r => r.isSolvable).reduce((sum, r) => sum + r.minMoves, 0) / solved).toFixed(1)
            : 0;
        
        let html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Brute-Force Results - ${new Date().toLocaleDateString()}</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #e94560; }
        .summary { background: #16213e; padding: 15px; border-radius: 8px; margin: 20px 0; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #0f3460; }
        th { background: #0f3460; }
        .ok { color: #4ade80; }
        .fail { color: #ef4444; }
        .warn { color: #fbbf24; }
    </style>
</head>
<body>
    <h1>üéÆ Brute-Force Analysis Results</h1>
    <p>Generated: ${new Date().toLocaleString()} | Source: ${currentSource.toUpperCase()} | Version: v1.8.20</p>
    
    <div class="summary">
        <h2>üìä Summary</h2>
        <p><strong>Total Levels:</strong> ${results.length}</p>
        <p><strong>Solvable:</strong> <span class="ok">${solved}</span></p>
        <p><strong>Unsolvable:</strong> <span class="fail">${results.length - solved}</span></p>
        <p><strong>Average Moves:</strong> ${avgMoves}</p>
    </div>
    
    <h2>üìã Results</h2>
    <table>
        <tr>
            <th>Level</th>
            <th>Status</th>
            <th>Min Moves</th>
            <th>States</th>
            <th>Time</th>
            <th>Error</th>
        </tr>`;
        
        results.forEach(r => {
            const statusClass = r.isSolvable ? 'ok' : 'fail';
            const status = r.isSolvable ? '‚úÖ OK' : '‚ùå FAIL';
            const moves = r.minMoves ?? '-';
            const states = r.statesExplored.toLocaleString();
            const time = Math.round(r.searchTime) + 'ms';
            const error = r.error || '-';
            const statesClass = r.statesExplored >= ALERTS.maxStatesWarning ? 'warn' : '';
            
            html += `
        <tr>
            <td>Level ${r.id}</td>
            <td class="${statusClass}">${status}</td>
            <td>${moves}</td>
            <td class="${statesClass}">${states}</td>
            <td>${time}</td>
            <td>${error}</td>
        </tr>`;
        });
        
        html += `
    </table>
</body>
</html>`;
        
        downloadFile(`brute_force_results_${Date.now()}.html`, html, 'text/html');
        log('üåê Exported results to HTML');
    }

    // ============ EVENT LISTENERS ============
    document.getElementById('speedSlider').addEventListener('input', (e) => {
        document.getElementById('speedValue').textContent = `${e.target.value}ms`;
        if (isPlaying) {
            stopAutoPlay();
            startAutoPlay();
        }
    });

    // ============ INIT ============
    // Set game engine version in UI
    document.getElementById('gameEngineVersion').textContent = GAME_ENGINE_VERSION;
    loadLevels();
    </script>
</body>
</html>


