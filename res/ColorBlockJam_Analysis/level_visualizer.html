<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Block Jam - Level Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="number"], input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .level-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .level-info h2 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .level-info p {
            color: #666;
            margin: 5px 0;
        }
        
        #canvas {
            border: 3px solid #333;
            border-radius: 8px;
            background: #f0f0f0;
            display: block;
            margin: 0 auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 250px;
        }
        
        .tooltip.show {
            display: block;
        }
        
        .tooltip h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #fff;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        
        .tooltip p {
            margin: 4px 0;
            color: #ddd;
        }
        
        .tooltip .label {
            color: #aaa;
            font-weight: normal;
        }
        
        .tooltip .value {
            color: #fff;
            font-weight: bold;
        }
        
        /* Search results dropdown */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 300px;
            overflow-y: auto;
            display: none;
            z-index: 100;
        }
        
        .search-results.show {
            display: block;
        }
        
        .search-result-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .search-result-item:hover {
            background: #f5f5f5;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item .name {
            font-weight: 600;
            color: #333;
        }
        
        .search-result-item .guid {
            font-size: 11px;
            color: #999;
            margin-top: 2px;
        }
        
        .verified-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ Color Block Jam - Level Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Level:</label>
                <input type="number" id="levelInput" value="1" min="1" max="1557">
                <button onclick="loadLevel()">Load Level</button>
            </div>
            <div class="control-group">
                <button onclick="prevLevel()">‚Üê Prev</button>
                <button onclick="nextLevel()">Next ‚Üí</button>
            </div>
            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="gameOrderToggle" checked onchange="toggleOrder()">
                    Game Order
                </label>
            </div>
            <div class="control-group">
                <label>Search:</label>
                <div style="position: relative;">
                    <input type="text" id="searchInput" placeholder="Level name or GUID" 
                           onkeyup="handleSearchInput(event)" 
                           onfocus="showSearchResults()"
                           onblur="hideSearchResults()">
                    <div id="searchResults" class="search-results"></div>
                </div>
                <button onclick="searchLevel()">Search</button>
            </div>
        </div>
        
        <div id="levelInfo" class="level-info" style="display: none;">
            <h2 id="levelName"></h2>
            <p><strong>Grid Size:</strong> <span id="gridSize"></span></p>
            <p><strong>Game Blocks:</strong> <span id="blockCount"></span></p>
            <p><strong>Doors:</strong> <span id="doorCount"></span> <span id="doorDetails" style="color: #667eea;"></span></p>
            <p><strong>GUID:</strong> <span id="levelGuid"></span></p>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="loading" class="loading">Loading levels data...</div>
        <div id="tooltip" class="tooltip"></div>
        <canvas id="canvas" style="display: none;"></canvas>
    </div>

    <script>
        let levels = [];
        let levelOrder = []; // –ü–æ—Ä—è–¥–æ–∫ —Ä—ñ–≤–Ω—ñ–≤ –∑ AllLevels_guids.json
        let currentLevelIndex = 0;
        let currentLevel = null; // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π —Ä—ñ–≤–µ–Ω—å –¥–ª—è tooltip
        let useGameOrder = true; // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ –∑ –≥—Ä–∏
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        // –ö–æ–ª—å–æ—Ä–æ–≤–∞ –ø–∞–ª—ñ—Ç—Ä–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ—ó –≥—Ä–∏ Color Block Jam
        const colorPalette = [
            '#03a5ef', // 0 - Blue (–ë–ª–∞–∫–∏—Ç–Ω–∏–π)
            '#143cf6', // 1 - Dark Blue (–¢–µ–º–Ω–æ-—Å–∏–Ω—ñ–π)
            '#48aa1a', // 2 - Green (–ó–µ–ª–µ–Ω–∏–π)
            '#b844c8', // 3 - Pink (–†–æ–∂–µ–≤–∏–π)
            '#7343db', // 4 - Purple (–§—ñ–æ–ª–µ—Ç–æ–≤–∏–π)
            '#fbb32d', // 5 - Yellow (–ñ–æ–≤—Ç–∏–π)
            '#09521d', // 6 - Dark Green (–¢–µ–º–Ω–æ-–∑–µ–ª–µ–Ω–∏–π)
            '#f2772b', // 7 - Orange (–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π)
            '#b8202c', // 8 - Red (–ß–µ—Ä–≤–æ–Ω–∏–π)
            '#0facae', // 9 - Cyan (–ë—ñ—Ä—é–∑–æ–≤–∏–π)
            '#EC7063', // 10 - –ö–æ—Ä–∞–ª–ª–æ–≤–∏–π
            '#795548', // 11 - –ö–æ—Ä–∏—á–Ω–µ–≤–∏–π
            '#607D8B', // 12 - –°—ñ—Ä–æ-—Å–∏–Ω—ñ–π
            '#FF5722', // 13 - –ì–ª–∏–±–æ–∫–∏–π –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π
            '#673AB7', // 14 - –ì–ª–∏–±–æ–∫–∏–π —Ñ—ñ–æ–ª–µ—Ç–æ–≤–∏–π
            '#009688', // 15 - –¢–µ–º–Ω–∏–π –±—ñ—Ä—é–∑–æ–≤–∏–π
        ];
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä—É –∑ –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–æ–º
        function getColorWithAlpha(colorIndex, alpha) {
            const baseColor = colorPalette[colorIndex] || '#999999';
            // –ü–µ—Ä–µ–∫–æ–Ω—É—î–º–æ—Å—å —â–æ –∫–æ–ª—ñ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç—ñ #RRGGBB
            const fullColor = baseColor.length === 4 
                ? '#' + baseColor[1] + baseColor[1] + baseColor[2] + baseColor[2] + baseColor[3] + baseColor[3]
                : baseColor;
            return fullColor + alpha;
        }
        
        // –§–æ—Ä–º–∏ –±–ª–æ–∫—ñ–≤ - pivot –≤ —Ü–µ–Ω—Ç—Ä—ñ –∞–±–æ –∫—É—Ç–∫—É —Ñ–æ—Ä–º–∏
        // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏: [dx, dy] –¥–µ dx=–∑–º—ñ—â–µ–Ω–Ω—è –ø–æ –∫–æ–ª–æ–Ω—Ü—ñ, dy=–∑–º—ñ—â–µ–Ω–Ω—è –ø–æ —Ä—è–¥–∫—É
        // dy: +1 = –≤–Ω–∏–∑, -1 = –≤–≥–æ—Ä—É
        // dx: +1 = –≤–ø—Ä–∞–≤–æ, -1 = –≤–ª—ñ–≤–æ
        const blockShapes = {
            0: [[0, 0]], // One - –æ–¥–Ω–∞ –∫–ª—ñ—Ç–∏–Ω–∫–∞
            1: [[0, -1], [0, 0]], // Two - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ 1x2 (pivot –∑–Ω–∏–∑—É, extends up)
            2: [[0, -1], [0, 0], [0, 1]], // Three - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ 1x3 (—Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∞)
            3: [[0, -1], [0, 0], [0, 1], [1, 1]], // L (4 –∫–ª—ñ—Ç–∏–Ω–∫–∏, —Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∏–π): X
                                               //                              X  <- pivot
                                               //                              X X
            4: [[-1, -1], [0, -1], [-1, 0], [-1, 1]], // ReverseL (4 –∫–ª—ñ—Ç–∏–Ω–∫–∏): X X
                                                      //                        X  <- pivot
                                                      //                        X
            5: [[-1, -1], [0, -1], [0, 0]], // ShortL: X X
                                          //            X (pivot –≤–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞)
            6: [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]], // Plus - —Ö—Ä–µ—Å—Ç (—Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∏–π)
            7: [[-1, -1], [0, -1], [-1, 0], [0, 0]], // TwoSquare - 2x2 (—Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∏–π, pivot –≤ –ø—Ä–∞–≤–æ–º—É –Ω–∏–∂–Ω—å–æ–º—É)
            8: [[-1, 0], [0, 0], [1, 0], [0, 1]], // ShortT - –¢-—Ñ–æ—Ä–º–∞ (—Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–∞)
            9: [[0, 0], [1, 0], [1, 1], [2, 1]], // Z
            10: [[1, 0], [2, 0], [0, 1], [1, 1]], // ReverseZ
            11: [[0, 0], [2, 0], [0, 1], [1, 1], [2, 1]], // U
        };
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö
        async function loadLevelsData() {
            try {
                // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Ä—ñ–≤–Ω—ñ
                const response = await fetch('level_data/parsed_levels_complete.json');
                if (!response.ok) {
                    throw new Error('Failed to load levels data');
                }
                const allLevels = await response.json();
                
                // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –ø–æ—Ä—è–¥–æ–∫ —Ä—ñ–≤–Ω—ñ–≤ –∑ –≥—Ä–∏
                const guidsResponse = await fetch('level_data/AllLevels_guids.json');
                if (guidsResponse.ok) {
                    const guidsData = await guidsResponse.json();
                    const guids = guidsData.level_guids;
                    
                    // –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞–ø—É GUID -> —Ä—ñ–≤–µ–Ω—å
                    const guidToLevel = {};
                    allLevels.forEach(level => {
                        guidToLevel[level.guid] = level;
                    });
                    
                    // –°–æ—Ä—Ç—É—î–º–æ —Ä—ñ–≤–Ω—ñ –∑–∞ –ø–æ—Ä—è–¥–∫–æ–º –∑ –≥—Ä–∏
                    levelOrder = guids.map((guid, idx) => ({
                        level: guidToLevel[guid],
                        gameIndex: idx + 1
                    })).filter(item => item.level);
                    
                    levels = levelOrder.map(item => item.level);
                    allLevelsGameOrder = levels;
                    allLevelsOriginal = allLevels;
                    console.log('Loaded ' + levels.length + ' levels in game order');
                } else {
                    // Fallback –¥–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫—É
                    levels = allLevels;
                    levelOrder = levels.map((level, idx) => ({ level, gameIndex: idx + 1 }));
                    useGameOrder = false;
                }
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('canvas').style.display = 'block';
                document.getElementById('levelInput').max = levels.length;
                loadLevel(0);
            } catch (error) {
                showError('Error loading levels: ' + error.message);
            }
        }
        
        // –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è cellSizeWorld –Ω–∞ –æ—Å–Ω–æ–≤—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –±–ª–æ–∫—ñ–≤ —Ä—ñ–≤–Ω—è
        function detectCellSize(level) {
            const blocks = level.gameBlocks || level.blocks || [];
            if (blocks.length < 2) return 2.0;
            
            // –î–ª—è –≤—Å—ñ—Ö —Ä—ñ–≤–Ω—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ cellSize=2 –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–æ–∑—Ç–∞—à—É–≤–∞–Ω–Ω—è
            return 2.0;
        }
        
        let currentCellSize = 2.0; // –ë—É–¥–µ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏—Å—å –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ä—ñ–≤–Ω—è
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è —Å–≤—ñ—Ç–æ–≤–∏—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ grid –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
        function worldToGrid(worldX, worldY, gridSize) {
            // Game block coordinates:
            // - World (0, 0) is the center of the grid
            // - Positive Y is up in world, but row 0 is at top of grid
            
            const cellSizeWorld = currentCellSize;
            
            // –¶–µ–Ω—Ç—Ä—É—î–º–æ —Å—ñ—Ç–∫—É
            const offsetX = (gridSize.x - 1) / 2;
            const offsetY = (gridSize.y - 1) / 2;
            
            let col = Math.round(worldX / cellSizeWorld + offsetX);
            let row = Math.round(-worldY / cellSizeWorld + offsetY);
            
            // Clamp to grid bounds
            row = Math.max(0, Math.min(row, gridSize.y - 1));
            col = Math.max(0, Math.min(col, gridSize.x - 1));
            
            return { row, col };
        }
        
        // –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è —Ä–æ—Ç–∞—Ü—ñ—ó –¥–æ —Ñ–æ—Ä–º–∏ –±–ª–æ–∫—É
        function rotateShape(shape, rotationY) {
            const rotations = Math.round(rotationY / 90) % 4;
            let rotated = shape.map(cell => [...cell]); // Deep copy
            
            for (let i = 0; i < rotations; i++) {
                rotated = rotated.map(([x, y]) => [-y, x]);
            }
            
            // –ù–ï –Ω–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ - –∑–∞–ª–∏—à–∞—î–º–æ —Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
            return rotated;
        }
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è
        function loadLevel(index = null) {
            if (index === null) {
                index = parseInt(document.getElementById('levelInput').value) - 1;
            }
            
            if (index < 0 || index >= levels.length) {
                showError('Invalid level index');
                return;
            }
            
            currentLevelIndex = index;
            const level = levels[index];
            currentLevel = level; // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–ª—è tooltip
            document.getElementById('levelInput').value = index + 1;
            
            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
            document.getElementById('levelInfo').style.display = 'block';
            const gameNum = levelOrder[index]?.gameIndex || (index + 1);
            document.getElementById('levelName').textContent = useGameOrder 
                ? `Game Level ${gameNum}: ${level.name}`
                : level.name;
            document.getElementById('gridSize').textContent = `${level.gridSize.x} √ó ${level.gridSize.y}`;
            // Use gameBlocks if available, fallback to blocks for old format
            const blocks = level.gameBlocks || level.blocks || [];
            document.getElementById('blockCount').textContent = blocks.length;
            document.getElementById('doorCount').textContent = level.doors.length;
            
            // –ü–æ–∫–∞–∑—É—î–º–æ –¥–µ—Ç–∞–ª—ñ –¥–≤–µ—Ä–µ–π (—Ç–∏–ø–∏/–∫–æ–ª—å–æ—Ä–∏)
            const colorNames = ['Red', 'Yellow', 'Green', 'Blue', 'Purple', 'Cyan', 'Magenta', 'Orange', 'Pink', 'DarkGray', 'Coral'];
            const doorDetails = level.doors.map(d => colorNames[d.blockType] || `Type${d.blockType}`).join(', ');
            document.getElementById('doorDetails').textContent = doorDetails ? `(${doorDetails})` : '';
            
            document.getElementById('levelGuid').textContent = level.guid;
            
            // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
            drawLevel(level);
            
            // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –ø–æ–¥—ñ–π –¥–ª—è tooltip
            setupTooltipHandlers();
            
            // –û–Ω–æ–≤–ª—é—î–º–æ badge –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
            updateVerificationBadge();
        }
        
        // –ú–∞–ª—é–≤–∞–Ω–Ω—è —Ä—ñ–≤–Ω—è
        // Helper function to check if edge columns are mostly hidden
        function getEdgeColumnHiddenInfo(level) {
            const hidden = level.hiddenCoords || [];
            const gridW = level.gridSize.x;
            const gridH = level.gridSize.y;
            
            if (hidden.length === 0) {
                return { leftHidden: false, rightHidden: false, leftCol: 0, rightCol: gridW - 1 };
            }
            
            // Count hidden cells in leftmost and rightmost columns
            let leftColHidden = 0;
            let rightColHidden = 0;
            
            hidden.forEach(h => {
                if (h.x === 0) leftColHidden++;
                if (h.x === gridW - 1) rightColHidden++;
            });
            
            // If more than 50% of cells in a column are hidden, consider it mostly hidden
            const threshold = gridH * 0.5;
            const leftMostlyHidden = leftColHidden >= threshold;
            const rightMostlyHidden = rightColHidden >= threshold;
            
            // Determine inner boundary columns
            const leftInnerCol = leftMostlyHidden ? 1 : 0;
            const rightInnerCol = rightMostlyHidden ? gridW - 2 : gridW - 1;
            
            return { 
                leftHidden: leftMostlyHidden, 
                rightHidden: rightMostlyHidden,
                leftCol: leftInnerCol,
                rightCol: rightInnerCol
            };
        }
        
        function drawLevel(level) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ cellSizeWorld –¥–ª—è —Ü—å–æ–≥–æ —Ä—ñ–≤–Ω—è
            currentCellSize = detectCellSize(level);
            console.log(`Level ${level.name}: detected cellSizeWorld = ${currentCellSize}`);
            
            const gridSize = level.gridSize;
            const cellSize = 50;
            const padding = 40;
            
            // Check edge column hidden state for dynamic door positioning
            const edgeInfo = getEdgeColumnHiddenInfo(level);
            console.log(`Edge info: leftHidden=${edgeInfo.leftHidden}, rightHidden=${edgeInfo.rightHidden}, leftCol=${edgeInfo.leftCol}, rightCol=${edgeInfo.rightCol}`);
            
            canvas.width = gridSize.x * cellSize + padding * 2;
            canvas.height = gridSize.y * cellSize + padding * 2;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –§–æ–Ω —Å—ñ—Ç–∫–∏
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –ú–∞–ª—é–≤–∞–Ω–Ω—è —Å—ñ—Ç–∫–∏
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 1;
            
            for (let r = 0; r <= gridSize.y; r++) {
                const y = padding + r * cellSize;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + gridSize.x * cellSize, y);
                ctx.stroke();
            }
            
            for (let c = 0; c <= gridSize.x; c++) {
                const x = padding + c * cellSize;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + gridSize.y * cellSize);
                ctx.stroke();
            }
            
            // –ü—Ä–∏—Ö–æ–≤–∞–Ω—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ (y=0 –≤ –¥–∞–Ω–∏—Ö = –Ω–∏–∂–Ω—ñ–π —Ä—è–¥ –≤ –≥—Ä—ñ)
            if (level.hiddenCoords && level.hiddenCoords.length > 0) {
                ctx.fillStyle = '#D0D0D0';
                level.hiddenCoords.forEach(coord => {
                    const col = coord.x;
                    const row = gridSize.y - 1 - coord.y; // –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ Y
                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    ctx.fillRect(x, y, cellSize, cellSize);
                });
            }
            
            // –ú–∞–ª—é–≤–∞–Ω–Ω—è –±–ª–æ–∫—ñ–≤ (—Å–ø–æ—á–∞—Ç–∫—É –±–ª–æ–∫–∏)
            // Use gameBlocks if available, fallback to blocks for old format
            const blocksToRender = level.gameBlocks || level.blocks || [];
            console.log(`Level ${currentLevelIndex + 1}: Total blocks in JSON: ${blocksToRender.length}`);
            let totalCellsDrawn = 0;
            const drawnCells = new Set(); // –î–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤
            
            blocksToRender.forEach((block, blockIdx) => {
                let gridPos = worldToGrid(block.position.x, block.position.y, gridSize);
                let shape = blockShapes[block.blockGroupType] || [[0, 0]];
                // Use Z rotation if non-zero, otherwise Y rotation
                const rotation = Math.abs(block.rotation.z || 0) > 1 ? block.rotation.z : (block.rotation.y || 0);
                let rotatedShape = rotateShape(shape, rotation);
                
                // ShortL: —Ä–æ—Ç–∞—Ü—ñ—è Z –≤–∏–∑–Ω–∞—á–∞—î –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é
                if (block.blockGroupType === 5) {
                    const rotZ = Math.round((block.rotation?.z || 0) / 90) % 4;
                    // –§–æ—Ä–º–∏ ShortL –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó:
                    // 0¬∞:   X X     (pivot –≤–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞) - extends up-left
                    //         X
                    // 90¬∞:  X       (extends down-right from pivot)
                    //       X X
                    // 180¬∞: X       (extends down-right from pivot)
                    //       X X
                    // 270¬∞:   X     (pivot –≤–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞) - extends up-left  
                    //       X X
                    const shortLShapes = {
                        0: [[-1, -1], [0, -1], [0, 0]],   // X X / __X - extends up
                        1: [[0, 0], [1, 0], [0, 1]],      // X X / X__ - extends down-left
                        2: [[0, 0], [0, 1], [1, 1]],      // X__ / X X - extends down-right (needs offset)
                        3: [[-1, 0], [0, -1], [0, 0]]     // __X / X X - extends up-left
                    };
                    rotatedShape = shortLShapes[rotZ] || shortLShapes[0];
                    
                    // –î–ª—è rotZ=1: —Ñ–æ—Ä–º–∞ X X / X__ –π–¥–µ –≤–Ω–∏–∑-–≤–ø—Ä–∞–≤–æ, –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑—Å—É–≤ –≤–ª—ñ–≤–æ-–≤–≥–æ—Ä—É
                    if (rotZ === 1) {
                        const atBottomEdge = (gridPos.row + 1) >= gridSize.y;
                        const atRightEdge = (gridPos.col + 1) >= gridSize.x;
                        
                        if (atBottomEdge && atRightEdge) {
                            // –ù–∞ –ø—Ä–∞–≤–æ–º—É-–Ω–∏–∂–Ω—å–æ–º—É –∫—É—Ç—ñ - —Ñ–æ—Ä–º–∞ –π–¥–µ –≤–≥–æ—Ä—É-–≤–ª—ñ–≤–æ, –∑—Å—É–≤ –≤–ª—ñ–≤–æ
                            gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                            rotatedShape = [[0, -1], [1, -1], [0, 0]]; // X X / __X
                        } else if (atBottomEdge) {
                            // –ù–∏–∂–Ω—ñ–π –∫—Ä–∞–π - —Ñ–æ—Ä–º–∞ –π–¥–µ –≤–≥–æ—Ä—É, –∑—Å—É–≤ –≤–ª—ñ–≤–æ
                            gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                            rotatedShape = [[0, -1], [1, -1], [0, 0]]; // X X / __X
                        } else {
                            // –ó–≤–∏—á–∞–π–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫ - –∑—Å—É–≤ –≤–ª—ñ–≤–æ —ñ –≤–≥–æ—Ä—É
                            gridPos = { row: gridPos.row - 1, col: gridPos.col - 1 };
                        }
                    }
                    
                    // –î–ª—è rotZ=2: –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑—Å—É–≤ –ø–æ col, —ñ –ø–æ row —è–∫—â–æ –±—ñ–ª—è –∫—Ä–∞—é –∞–±–æ hidden cells
                    if (rotZ === 2) {
                        const atTopEdge = gridPos.row <= 1;
                        const atBottomEdge = (gridPos.row + 1) >= gridSize.y;
                        const hasHiddenCells = level.hiddenCoords && level.hiddenCoords.length > 0;
                        const worldY = block.position.y;
                        
                        // Special case: Level 36 (Game Level 21) green ShortL should be 1 cell lower
                        if (level.name === 'Level 36' && block.blockType === 2) {
                            gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                        }
                        // –î–ª—è —Ä—ñ–≤–Ω—ñ–≤ –∑ hidden cells —ñ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏–º worldY - –∑–∞–≤–∂–¥–∏ –∑—Å—É–≤ –≤–≥–æ—Ä—É
                        else if (hasHiddenCells && worldY < 0) {
                            gridPos = { row: gridPos.row - 1, col: gridPos.col - 1 };
                        } else if (atTopEdge) {
                            // –ë—ñ–ª—è –≤–µ—Ä—Ö–Ω—å–æ–≥–æ –∫—Ä–∞—é - –∑—Å—É–≤ –≤–≥–æ—Ä—É
                            gridPos = { row: gridPos.row - 1, col: gridPos.col - 1 };
                        } else if (atBottomEdge) {
                            // –ë—ñ–ª—è –Ω–∏–∂–Ω—å–æ–≥–æ –∫—Ä–∞—é - –∑—Å—É–≤ –≤–≥–æ—Ä—É  
                            gridPos = { row: gridPos.row - 1, col: gridPos.col - 1 };
                        } else {
                            // –ó–≤–∏—á–∞–π–Ω–∏–π –∑—Å—É–≤ —Ç—ñ–ª—å–∫–∏ –ø–æ col
                            gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                        }
                    }
                    console.log('ShortL rotZ=' + rotZ + ' at', gridPos);
                }
                
                // ShortT: —Ä–æ—Ç–∞—Ü—ñ—è Z –≤–∏–∑–Ω–∞—á–∞—î –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —è–≤–Ω—ñ —Ñ–æ—Ä–º–∏ –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó
                if (block.blockGroupType === 8) {
                    const rotZ = Math.round((block.rotation?.z || 0) / 90) % 4;
                    // –§–æ—Ä–º–∏ ShortT –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó:
                    // rotZ=0: T –≤–Ω–∏–∑      rotZ=1: T –≤–ø—Ä–∞–≤–æ    rotZ=2: T –≤–≥–æ—Ä—É     rotZ=3: T –≤–ª—ñ–≤–æ
                    //   X X X               X                     X                   X
                    //     X                 X X                 X X X               X X
                    //                       X                                         X
                    const shortTShapes = {
                        0: [[-1, 0], [0, 0], [1, 0], [0, 1]],    // X X X / __X__ - stem down
                        1: [[0, -1], [0, 0], [1, 0], [0, 1]],    // X / X X / X - stem right
                        2: [[0, -1], [-1, 0], [0, 0], [1, 0]],   // __X__ / X X X - stem up
                        3: [[0, -1], [-1, 0], [0, 0], [0, 1]]    // __X / X X / __X - stem left
                    };
                    rotatedShape = shortTShapes[rotZ] || shortTShapes[0];
                    
                    // –ö–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–æ—Ç–∞—Ü—ñ—ó
                    // rotZ=0: –∑—Å—É–≤ –≤–≥–æ—Ä—É –Ω–∞ 1 (pivot –≤–Ω–∏–∑—É T)
                    // rotZ=1: –∑—Å—É–≤ –≤–ª—ñ–≤–æ –Ω–∞ 1 (pivot —Å–ø—Ä–∞–≤–∞ T)
                    // rotZ=2: –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –∑–Ω–∞–∫—É Y - —è–∫—â–æ Y > 0, –∑—Å—É–≤ –≤–Ω–∏–∑; —è–∫—â–æ Y < 0, –±–µ–∑ –∑—Å—É–≤—É
                    // rotZ=3: –±–µ–∑ –∑—Å—É–≤—É (pivot –∑–ª—ñ–≤–∞ T)
                    if (rotZ === 0) {
                        gridPos = { row: gridPos.row - 1, col: gridPos.col };
                    } else if (rotZ === 1) {
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    } else if (rotZ === 2) {
                        // –î–ª—è –ø–æ–∑–∏—Ç–∏–≤–Ω–æ–≥–æ Y –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑—Å—É–≤ –≤–Ω–∏–∑, –¥–ª—è –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–≥–æ - –±–µ–∑ –∑—Å—É–≤—É
                        // Special case: Level 36 (Game Level 21) orange ShortT should be 1 cell higher
                        if (level.name === 'Level 36' && block.blockType === 7) {
                            // No offset for this block
                        } else if (block.position.y > 0) {
                            gridPos = { row: gridPos.row + 1, col: gridPos.col };
                        }
                    }
                    // rotZ=3: –±–µ–∑ –∑—Å—É–≤—É
                    console.log('ShortT rotZ=' + rotZ + ', worldY=' + block.position.y + ' at', gridPos);
                }
                
                // Double: –∫–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–æ—Ç–∞—Ü—ñ—ó
                if (block.blockGroupType === 1) {
                    const rotZ = Math.round((block.rotation?.z || 0) / 90) % 4;
                    // Double –±–∞–∑–æ–≤–∞ —Ñ–æ—Ä–º–∞: X (extends up from pivot)
                    //                      X (pivot)
                    // rotZ=1 (90¬∞): —Ñ–æ—Ä–º–∞ –π–¥–µ –≤–ø—Ä–∞–≤–æ, –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑—Å—É–≤ –≤–ª—ñ–≤–æ
                    // rotZ=2 (180¬∞): —Ñ–æ—Ä–º–∞ –π–¥–µ –≤–Ω–∏–∑, –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑—Å—É–≤ –≤–≥–æ—Ä—É
                    // rotZ=3 (270¬∞): —Ñ–æ—Ä–º–∞ –π–¥–µ –≤–ª—ñ–≤–æ - OK
                    if (rotZ === 1) {
                        // –ó—Å—É–≤–∞—î–º–æ –≤–ª—ñ–≤–æ –Ω–∞ 1 –∫–ª—ñ—Ç–∏–Ω–∫—É
                        if (gridPos.col > 0) {
                            gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                        }
                    } else if (rotZ === 2) {
                        // –ó—Å—É–≤–∞—î–º–æ –≤–≥–æ—Ä—É –Ω–∞ 1 –∫–ª—ñ—Ç–∏–Ω–∫—É
                        if (gridPos.row > 0) {
                            gridPos = { row: gridPos.row - 1, col: gridPos.col };
                        }
                    }
                    console.log('Double rotZ=' + rotZ + ' at', gridPos);
                }
                
                // –ö–æ—Ä–∏–≥—É—î–º–æ L —Ñ–æ—Ä–º–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–æ—Ç–∞—Ü—ñ—ó
                const rotationNorm = Math.abs(Math.round(rotation / 90) % 4);
                if (block.blockGroupType === 3) {
                    // L –±–ª–æ–∫: —Ä—ñ–∑–Ω–∞ –æ–±—Ä–æ–±–∫–∞ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ä–æ—Ç–∞—Ü—ñ–π
                    if (rotationNorm === 0) {
                        // rotZ=0: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –¥–∑–µ—Ä–∫–∞–ª—å–Ω—É —Ñ–æ—Ä–º—É (X X / _X / _X) + –∑—Å—É–≤ –≤–ª—ñ–≤–æ
                        rotatedShape = [[0, -1], [1, -1], [1, 0], [1, 1]];
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    } else if (rotationNorm === 2) {
                        // rotZ=2 (180¬∞): –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—É L —Ñ–æ—Ä–º—É
                        rotatedShape = [[0, -1], [0, 0], [0, 1], [1, 1]];
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    }
                }
                
                // ReverseL: —è–≤–Ω—ñ —Ñ–æ—Ä–º–∏ –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó
                if (block.blockGroupType === 4) {
                    // ReverseL (–¥–∑–µ—Ä–∫–∞–ª—å–Ω–∞ L) —Ñ–æ—Ä–º–∏ –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó:
                    // rotZ=0: X X    rotZ=1: X _ _    rotZ=2: _ X    rotZ=3: _ _ X
                    //         X _           X X X           _ X           X X X
                    //         X _                           X X
                    const reverseLShapes = {
                        0: [[-1, -1], [0, -1], [-1, 0], [-1, 1]],  // X X / X_ / X_
                        1: [[-1, -1], [-1, 0], [0, 0], [1, 0]],    // X__ / XXX
                        2: [[1, -1], [1, 0], [0, 1], [1, 1]],      // _X / _X / XX
                        3: [[-1, 0], [0, 0], [1, 0], [1, 1]]       // XXX / __X
                    };
                    rotatedShape = reverseLShapes[rotationNorm] || reverseLShapes[0];
                    
                    // –ö–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ä–æ—Ç–∞—Ü—ñ—ó
                    if (rotationNorm === 0) {
                        // –ë–µ–∑ –∑—Å—É–≤—É
                    } else if (rotationNorm === 1) {
                        // –ë–µ–∑ –∑—Å—É–≤—É
                    } else if (rotationNorm === 2) {
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    } else if (rotationNorm === 3) {
                        // –ó—Å—É–≤ –≤–≥–æ—Ä—É –Ω–∞ 1
                        gridPos = { row: gridPos.row - 1, col: gridPos.col };
                    }
                    console.log('ReverseL rotZ=' + rotationNorm + ' at', gridPos);
                }
                
                const color = colorPalette[block.blockType] || '#999999';
                
                console.log(`Block ${blockIdx + 1}: type=${block.blockGroupTypeName} (${block.blockGroupType}), world=(${block.position.x.toFixed(2)}, ${block.position.y.toFixed(2)}), grid=(${gridPos.row}, ${gridPos.col}), scale=(${block.scale?.x?.toFixed(2) || 1.0}, ${block.scale?.y?.toFixed(2) || 1.0}), rotation.y=${block.rotation?.y || 0}, shape cells=${rotatedShape.length}, cells: ${rotatedShape.map(([dx, dy]) => `(${gridPos.row + dy}, ${gridPos.col + dx})`).join(', ')}`);
                
                // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –±–ª–æ–∫—É
                const blockCells = [];
                const cellSet = new Set();
                
                rotatedShape.forEach(([dx, dy]) => {
                    const col = gridPos.col + dx;
                    const row = gridPos.row + dy;
                    
                    if (col >= 0 && col < gridSize.x && row >= 0 && row < gridSize.y) {
                        blockCells.push({ col, row });
                        cellSet.add(`${col},${row}`);
                        
                        const cellKey = `${row},${col}`;
                        if (drawnCells.has(cellKey)) {
                            console.warn(`‚ö†Ô∏è Duplicate cell at (${row}, ${col}) for block ${blockIdx + 1}`);
                        }
                        drawnCells.add(cellKey);
                        totalCellsDrawn++;
                    }
                });
                
                // –ú–∞–ª—é—î–º–æ –∑–∞–ª–∏–≤–∫—É –¥–ª—è –≤—Å—ñ—Ö –∫–ª—ñ—Ç–∏–Ω–æ–∫ (—Ü—ñ–ª—ñ—Å–Ω–æ, –±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤ –º—ñ–∂ —Å—É—Å—ñ–¥–Ω—ñ–º–∏)
                blockCells.forEach(({ col, row }) => {
                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    
                    // –í–∏–∑–Ω–∞—á–∞—î–º–æ –≤—ñ–¥—Å—Ç—É–ø–∏ –¥–ª—è –∫–æ–∂–Ω–æ—ó —Å—Ç–æ—Ä–æ–Ω–∏
                    // –Ø–∫—â–æ —î —Å—É—Å—ñ–¥ - –≤—ñ–¥—Å—Ç—É–ø 0, —è–∫—â–æ –Ω–µ–º–∞—î - –≤—ñ–¥—Å—Ç—É–ø 2
                    const hasTop = cellSet.has(`${col},${row - 1}`);
                    const hasBottom = cellSet.has(`${col},${row + 1}`);
                    const hasLeft = cellSet.has(`${col - 1},${row}`);
                    const hasRight = cellSet.has(`${col + 1},${row}`);
                    
                    const marginTop = hasTop ? 0 : 2;
                    const marginBottom = hasBottom ? 0 : 2;
                    const marginLeft = hasLeft ? 0 : 2;
                    const marginRight = hasRight ? 0 : 2;
                    
                    const rectX = x + marginLeft;
                    const rectY = y + marginTop;
                    const rectW = cellSize - marginLeft - marginRight;
                    const rectH = cellSize - marginTop - marginBottom;
                    
                    // –ì—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è –±–ª–æ–∫—É
                    const gradient = ctx.createLinearGradient(x, y, x + cellSize, y + cellSize);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, color + 'DD');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(rectX, rectY, rectW, rectH);
                });
                
                // –ú–∞–ª—é—î–º–æ –æ–±–≤–æ–¥–∫—É —Ç—ñ–ª—å–∫–∏ –Ω–∞ –∑–æ–≤–Ω—ñ—à–Ω—ñ—Ö –∫—Ä–∞—è—Ö —Ñ—ñ–≥—É—Ä–∏
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                
                blockCells.forEach(({ col, row }) => {
                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    
                    // –í–∏–∑–Ω–∞—á–∞—î–º–æ –≤—ñ–¥—Å—Ç—É–ø–∏ –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –æ–±–≤–æ–¥–∫–∏
                    const hasTop = cellSet.has(`${col},${row - 1}`);
                    const hasBottom = cellSet.has(`${col},${row + 1}`);
                    const hasLeft = cellSet.has(`${col - 1},${row}`);
                    const hasRight = cellSet.has(`${col + 1},${row}`);
                    
                    const marginTop = hasTop ? 0 : 2;
                    const marginBottom = hasBottom ? 0 : 2;
                    const marginLeft = hasLeft ? 0 : 2;
                    const marginRight = hasRight ? 0 : 2;
                    
                    const rectX = x + marginLeft;
                    const rectY = y + marginTop;
                    const rectW = cellSize - marginLeft - marginRight;
                    const rectH = cellSize - marginTop - marginBottom;
                    
                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–Ω—É —Å—Ç–æ—Ä–æ–Ω—É - –º–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—é —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ–º–∞—î —Å—É—Å—ñ–¥–∞
                    // –í–µ—Ä—Ö–Ω—è —Å—Ç–æ—Ä–æ–Ω–∞
                    if (!hasTop) {
                        ctx.beginPath();
                        ctx.moveTo(rectX, rectY);
                        ctx.lineTo(rectX + rectW, rectY);
                        ctx.stroke();
                    }
                    // –ù–∏–∂–Ω—è —Å—Ç–æ—Ä–æ–Ω–∞
                    if (!hasBottom) {
                        ctx.beginPath();
                        ctx.moveTo(rectX, rectY + rectH);
                        ctx.lineTo(rectX + rectW, rectY + rectH);
                        ctx.stroke();
                    }
                    // –õ—ñ–≤–∞ —Å—Ç–æ—Ä–æ–Ω–∞
                    if (!hasLeft) {
                        ctx.beginPath();
                        ctx.moveTo(rectX, rectY);
                        ctx.lineTo(rectX, rectY + rectH);
                        ctx.stroke();
                    }
                    // –ü—Ä–∞–≤–∞ —Å—Ç–æ—Ä–æ–Ω–∞
                    if (!hasRight) {
                        ctx.beginPath();
                        ctx.moveTo(rectX + rectW, rectY);
                        ctx.lineTo(rectX + rectW, rectY + rectH);
                        ctx.stroke();
                    }
                });
            });
            
            console.log(`Total cells drawn: ${totalCellsDrawn}, Unique cells: ${drawnCells.size}`);
            
            // –ú–∞–ª—é–≤–∞–Ω–Ω—è –¥–≤–µ—Ä–µ–π (–ø—ñ—Å–ª—è –±–ª–æ–∫—ñ–≤, —â–æ–± –±—É–ª–∏ –≤–∏–¥–∏–º—ñ)
            console.log(`Drawing ${level.doors.length} doors:`);
            
            level.doors.forEach((door, idx) => {
                const doorPartCount = door.doorPartCount || 1;
                const color = colorPalette[door.blockType] || '#999999';
                
                const worldX = door.position.x;
                const worldY = door.position.y;
                
                let edge = 'unknown';
                let doorX, doorY, doorWidth, doorHeight;
                const doorThickness = 12;
                const doorLength = cellSize * doorPartCount;
                
                // –í–∏–∑–Ω–∞—á–∞—î–º–æ –∫—Ä–∞–π –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (–¥–∏–Ω–∞–º—ñ—á–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ä–æ–∑–º—ñ—Ä—É —Å—ñ—Ç–∫–∏)
                const absX = Math.abs(worldX);
                const absY = Math.abs(worldY);
                
                // –î–∏–Ω–∞–º—ñ—á–Ω—ñ –ø–æ—Ä–æ–≥–∏ –¥–ª—è –∫—Ä–∞—ó–≤
                // –Ø–∫—â–æ –∫—Ä–∞—ó –∫–æ–ª–æ–Ω–∫–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º—É –ø—Ä–∏—Ö–æ–≤–∞–Ω—ñ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–∏–∂—á–∏–π –ø–æ—Ä—ñ–≥
                let sideEdgeThreshold = Math.max(3.5, gridSize.x + 0.5);
                if (edgeInfo.leftHidden || edgeInfo.rightHidden) {
                    // –ó–Ω–∏–∂—É—î–º–æ –ø–æ—Ä—ñ–≥, —â–æ–± –¥–≤–µ—Ä—ñ –Ω–∞ –ø–æ–∑–∏—Ü—ñ—è—Ö gridSize.x-1 —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–ª–∏—Å—å —è–∫ –±–æ–∫–æ–≤—ñ
                    // –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è grid 6x8: –ø–æ—Ä—ñ–≥ 4.9 –ª–æ–≤–∏—Ç—å –¥–≤–µ—Ä—ñ –Ω–∞ x=¬±5
                    sideEdgeThreshold = gridSize.x - 1.1;
                }
                const topBottomEdgeThreshold = Math.max(5.5, gridSize.y - 0.5);
                
                // –°–ü–û–ß–ê–¢–ö–£ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –±–æ–∫–æ–≤—ñ –∫—Ä–∞—ó
                if (absX >= sideEdgeThreshold) {
                    // –õ—ñ–≤–∏–π –∞–±–æ –ø—Ä–∞–≤–∏–π –∫—Ä–∞–π
                    let doorStartRow;
                    if (Math.abs(worldY) < 0.5) {
                        // –¶–µ–Ω—Ç—Ä–æ–≤–∞–Ω—ñ –¥–≤–µ—Ä—ñ
                        doorStartRow = Math.floor((gridSize.y - doorPartCount) / 2);
                    } else {
                        // –ó–º—ñ—â–µ–Ω—ñ –¥–≤–µ—Ä—ñ: –∫–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ worldY –≤ row (—Ç–∞–∫ —Å–∞–º–æ —è–∫ –±–ª–æ–∫–∏)
                        const offsetY = (gridSize.y - 1) / 2;
                        const rowCenter = Math.round(-worldY / currentCellSize + offsetY);
                        // –î–ª—è —Å–∏–ª—å–Ω–æ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏—Ö worldY (–Ω–∏–∂–Ω—è —á–∞—Å—Ç–∏–Ω–∞ –ø–æ–ª—è), –∑—Å—É–≤ –º–µ–Ω—à–∏–π
                        // –î–ª—è worldY –±–ª–∏–∑—å–∫–∏—Ö –¥–æ 0 –∞–±–æ –ø–æ–∑–∏—Ç–∏–≤–Ω–∏—Ö - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π –∑—Å—É–≤
                        if (worldY < -2) {
                            doorStartRow = rowCenter - Math.floor((doorPartCount - 1) / 2);
                        } else {
                            doorStartRow = rowCenter - Math.floor(doorPartCount / 2);
                        }
                    }
                    doorStartRow = Math.max(0, Math.min(doorStartRow, gridSize.y - doorPartCount));
                    
                    // Special case: Level 25 (Game Level 16) right blue door should be 1 cell higher
                    if (level.name === 'Level 25' && worldX > 0 && door.blockType === 0) {
                        doorStartRow = doorStartRow - 1;
                    }
                    
                    // Special case: Level 36 (Game Level 21) left orange door should be 1 cell higher
                    if (level.name === 'Level 36' && worldX < 0 && door.blockType === 7) {
                        doorStartRow = doorStartRow - 1;
                    }
                    
                    if (worldX > 0) {
                        edge = 'right';
                        // –Ø–∫—â–æ –ø—Ä–∞–≤–∞ –∫–æ–ª–æ–Ω–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º—É –ø—Ä–∏—Ö–æ–≤–∞–Ω–∞, –º–∞–ª—é—î–º–æ –¥–≤–µ—Ä—ñ –Ω–∞ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –º–µ–∂—ñ
                        if (edgeInfo.rightHidden) {
                            doorX = padding + (edgeInfo.rightCol + 1) * cellSize - doorThickness - 2;
                        } else {
                            doorX = padding + gridSize.x * cellSize + 2;
                        }
                    } else {
                        edge = 'left';
                        // –Ø–∫—â–æ –ª—ñ–≤–∞ –∫–æ–ª–æ–Ω–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º—É –ø—Ä–∏—Ö–æ–≤–∞–Ω–∞, –º–∞–ª—é—î–º–æ –¥–≤–µ—Ä—ñ –Ω–∞ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –º–µ–∂—ñ
                        if (edgeInfo.leftHidden) {
                            doorX = padding + edgeInfo.leftCol * cellSize + 2;
                        } else {
                            doorX = padding - doorThickness - 2;
                        }
                    }
                    doorY = padding + doorStartRow * cellSize;
                    doorWidth = doorThickness;
                    doorHeight = doorLength;
                } else if (absY >= topBottomEdgeThreshold) {
                    // –í–µ—Ä—Ö–Ω—ñ–π –∞–±–æ –Ω–∏–∂–Ω—ñ–π –∫—Ä–∞–π
                    let doorStartCol;
                    if (Math.abs(worldX) < 0.5) {
                        // –¶–µ–Ω—Ç—Ä–æ–≤–∞–Ω—ñ –¥–≤–µ—Ä—ñ
                        doorStartCol = Math.floor((gridSize.x - doorPartCount) / 2);
                    } else {
                        // –ó–º—ñ—â–µ–Ω—ñ –¥–≤–µ—Ä—ñ: –∫–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ worldX –≤ col (—Ç–∞–∫ —Å–∞–º–æ —è–∫ –±–ª–æ–∫–∏)
                        const offsetX = (gridSize.x - 1) / 2;
                        const colCenter = Math.round(worldX / currentCellSize + offsetX);
                        doorStartCol = colCenter - Math.floor(doorPartCount / 2);
                    }
                    doorStartCol = Math.max(0, Math.min(doorStartCol, gridSize.x - doorPartCount));
                    
                    if (worldY > 0) {
                        edge = 'top';
                        doorX = padding + doorStartCol * cellSize;
                        doorY = padding - doorThickness - 2;
                    } else {
                        edge = 'bottom';
                        doorX = padding + doorStartCol * cellSize;
                        doorY = padding + gridSize.y * cellSize + 2;
                    }
                    doorWidth = doorLength;
                    doorHeight = doorThickness;
                } else {
                    // –†–µ–∑–µ—Ä–≤–Ω–∏–π –º–µ—Ç–æ–¥: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ rotation.z
                    const rotZ = door.rotation?.z || 0;
                    const normalizedRot = ((rotZ % 360) + 360) % 360;
                    
                    if (normalizedRot >= 135 && normalizedRot < 225) {
                        edge = 'top-fallback';
                        doorX = padding + Math.floor((gridSize.x - doorPartCount) / 2) * cellSize;
                        doorY = padding - doorThickness - 2;
                        doorWidth = doorLength;
                        doorHeight = doorThickness;
                    } else if (normalizedRot >= 45 && normalizedRot < 135) {
                        edge = 'right-fallback';
                        doorX = padding + gridSize.x * cellSize + 2;
                        doorY = padding + Math.floor((gridSize.y - doorPartCount) / 2) * cellSize;
                        doorWidth = doorThickness;
                        doorHeight = doorLength;
                    } else if (normalizedRot >= 225 && normalizedRot < 315) {
                        edge = 'left-fallback';
                        doorX = padding - doorThickness - 2;
                        doorY = padding + Math.floor((gridSize.y - doorPartCount) / 2) * cellSize;
                        doorWidth = doorThickness;
                        doorHeight = doorLength;
                    } else {
                        edge = 'bottom-fallback';
                        doorX = padding + Math.floor((gridSize.x - doorPartCount) / 2) * cellSize;
                        doorY = padding + gridSize.y * cellSize + 2;
                        doorWidth = doorLength;
                        doorHeight = doorThickness;
                    }
                }
                
                console.log(`  Door ${idx + 1}: edge=${edge}, world=(${worldX.toFixed(1)}, ${worldY.toFixed(1)}), type=${door.blockType}, parts=${doorPartCount}, pos=(${doorX}, ${doorY}), size=${doorWidth}x${doorHeight}`);
                
                // –¢—ñ–Ω—å –¥–ª—è –¥–≤–µ—Ä–µ–π
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // –ó–∞–ø–æ–≤–Ω–µ–Ω–Ω—è –¥–≤–µ—Ä–µ–π (–Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–µ)
                const gradient = ctx.createLinearGradient(doorX, doorY, doorX + doorWidth, doorY + doorHeight);
                gradient.addColorStop(0, color + 'DD');
                gradient.addColorStop(0.5, color + 'AA');
                gradient.addColorStop(1, color + '88');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                
                // –¢–æ–≤—Å—Ç–∞ —Ä–∞–º–∫–∞ –Ω–∞–≤–∫–æ–ª–æ –¥–≤–µ—Ä–µ–π
                ctx.shadowColor = 'transparent';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);
                
                // –í–Ω—É—Ç—Ä—ñ—à–Ω—è –±—ñ–ª–∞ –æ–±–≤–æ–¥–∫–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç—É
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(doorX + 1, doorY + 1, doorWidth - 2, doorHeight - 2);
                
                // –ü–æ–∫–∞–∑—É—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —á–∞—Å—Ç–∏–Ω, —è–∫—â–æ –±—ñ–ª—å—à–µ 1
                if (doorPartCount > 1) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(doorPartCount.toString(), doorX + doorWidth / 2, doorY + doorHeight / 2);
                }
            });
        }
        
        // –ù–∞–≤—ñ–≥–∞—Ü—ñ—è
        function prevLevel() {
            if (currentLevelIndex > 0) {
                loadLevel(currentLevelIndex - 1);
            }
        }
        
        function nextLevel() {
            if (currentLevelIndex < levels.length - 1) {
                loadLevel(currentLevelIndex + 1);
            }
        }
        
        // –ü–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –ø–æ—Ä—è–¥–∫—É (Game Order / File Order)
        let allLevelsOriginal = null;
        let allLevelsGameOrder = null;
        
        async function toggleOrder() {
            const useGame = document.getElementById('gameOrderToggle').checked;
            useGameOrder = useGame;
            
            if (!allLevelsOriginal) {
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ –ø—Ä–∏ –ø–µ—Ä—à–æ–º—É –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—ñ
                const response = await fetch('level_data/parsed_levels_complete.json');
                allLevelsOriginal = await response.json();
            }
            
            if (useGame && allLevelsGameOrder) {
                levels = allLevelsGameOrder;
            } else if (!useGame) {
                levels = allLevelsOriginal;
                levelOrder = levels.map((level, idx) => ({ level, gameIndex: idx + 1 }));
            } else {
                levels = allLevelsGameOrder || levels;
            }
            
            document.getElementById('levelInput').max = levels.length;
            loadLevel(0);
        }
        
        // –ü–æ—à—É–∫
        function searchLevel() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            
            const queryLower = query.toLowerCase();
            let index = levels.findIndex(level => 
                level.name.toLowerCase().includes(queryLower) ||
                level.guid.toLowerCase().includes(queryLower)
            );
            
            // –Ø–∫—â–æ "Level N" –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ "Derin Level N"
            if (index === -1) {
                const levelMatch = query.match(/^level\s*(\d+)$/i);
                if (levelMatch) {
                    const num = levelMatch[1];
                    const derinQuery = `derin level ${num}`;
                    index = levels.findIndex(level => 
                        level.name.toLowerCase() === derinQuery
                    );
                    if (index !== -1) {
                        console.log(`"Level ${num}" not found, using "Derin Level ${num}" instead`);
                    }
                }
            }
            
            if (index !== -1) {
                loadLevel(index);
                document.getElementById('searchInput').value = '';
                hideSearchResults();
            } else {
                showError(`Level not found: "${query}". Note: Some levels (7, 10, 11, etc.) don't exist in APK`);
            }
        }
        
        // –û–±—Ä–æ–±–∫–∞ –≤–≤–æ–¥—É –≤ –ø–æ–ª–µ –ø–æ—à—É–∫—É (–∞–≤—Ç–æ–∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è)
        function handleSearchInput(e) {
            const query = e.target.value.trim();
            const searchResults = document.getElementById('searchResults');
            
            if (query.length < 2) {
                hideSearchResults();
                return;
            }
            
            if (e.key === 'Enter') {
                searchLevel();
                return;
            }
            
            showSearchResults();
            updateSearchResults(query);
        }
        
        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –ø–æ—à—É–∫—É
        function updateSearchResults(query) {
            const queryLower = query.toLowerCase();
            const searchResults = document.getElementById('searchResults');
            
            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ —Ä—ñ–≤–Ω—ñ —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –∑–∞–ø–∏—Ç—É
            const matches = levels
                .map((level, index) => ({ level, index }))
                .filter(({ level }) => 
                    level.name.toLowerCase().includes(queryLower) ||
                    level.guid.toLowerCase().includes(queryLower)
                )
                .map(({ level, index }) => {
                    // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: —Ç–æ—á–Ω–∏–π –∑–±—ñ–≥ –ø–æ name > –ø–æ—á–∞—Ç–æ–∫ name > GUID
                    let priority = 0;
                    const nameLower = level.name.toLowerCase();
                    if (nameLower === queryLower) {
                        priority = 3; // –¢–æ—á–Ω–∏–π –∑–±—ñ–≥
                    } else if (nameLower.startsWith(queryLower)) {
                        priority = 2; // –ü–æ—á–∞—Ç–æ–∫ –Ω–∞–∑–≤–∏
                    } else if (nameLower.includes(queryLower)) {
                        priority = 1; // –ú—ñ—Å—Ç–∏—Ç—å –≤ –Ω–∞–∑–≤—ñ
                    } else {
                        priority = 0; // –¢—ñ–ª—å–∫–∏ GUID
                    }
                    return { level, index, priority };
                })
                .sort((a, b) => b.priority - a.priority) // –°–æ—Ä—Ç—É—î–º–æ –∑–∞ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–æ–º
                .slice(0, 10); // –û–±–º–µ–∂—É—î–º–æ –¥–æ 10 —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div class="search-result-item" style="color: #999; cursor: default;">No results found</div>';
                return;
            }
            
            // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø—ñ–¥—Å–≤—ñ—Ç–∫–∏ –∑–±—ñ–≥—ñ–≤
            function highlightMatch(text, query) {
                if (!query) return text;
                const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                return text.replace(regex, '<mark style="background: #ffeb3b; padding: 2px 0;">$1</mark>');
            }
            
            searchResults.innerHTML = matches.map(({ level, index }) => `
                <div class="search-result-item" onclick="loadLevel(${index}); document.getElementById('searchInput').value=''; hideSearchResults();">
                    <div class="name">${highlightMatch(level.name, query)}</div>
                    <div class="guid">GUID: ${level.guid}</div>
                </div>
            `).join('');
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É
        function showSearchResults() {
            const query = document.getElementById('searchInput').value.trim();
            if (query.length >= 2) {
                document.getElementById('searchResults').classList.add('show');
                updateSearchResults(query);
            }
        }
        
        // –ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É
        function hideSearchResults() {
            // –ó–∞—Ç—Ä–∏–º–∫–∞ —â–æ–± –¥–∞—Ç–∏ —á–∞—Å –Ω–∞ –∫–ª—ñ–∫ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
            setTimeout(() => {
                document.getElementById('searchResults').classList.remove('show');
            }, 200);
        }
        
        // –ü–æ–º–∏–ª–∫–∏
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –±–ª–æ–∫—É –ø—ñ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
        function getBlockAtPosition(mouseX, mouseY) {
            if (!currentLevel) return null;
            
            const gridSize = currentLevel.gridSize;
            const cellSize = 50;
            const padding = 40;
            
            // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –º–∏—à—ñ –≤ grid –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
            const col = Math.floor((mouseX - padding) / cellSize);
            const row = Math.floor((mouseY - padding) / cellSize);
            
            if (col < 0 || col >= gridSize.x || row < 0 || row >= gridSize.y) {
                return null;
            }
            
            // –®—É–∫–∞—î–º–æ –±–ª–æ–∫, —è–∫–∏–π –∑–∞–π–º–∞—î —Ü—é –∫–ª—ñ—Ç–∏–Ω–∫—É
            const blocksToSearch = currentLevel.gameBlocks || currentLevel.blocks || [];
            for (const block of blocksToSearch) {
                let gridPos = worldToGrid(block.position.x, block.position.y, gridSize);
                const shape = blockShapes[block.blockGroupType] || [[0, 0]];
                // Use Z rotation if non-zero, otherwise Y rotation
                const rotation = Math.abs(block.rotation.z || 0) > 1 ? block.rotation.z : (block.rotation.y || 0);
                let rotatedShape = rotateShape(shape, rotation);
                
                // –ö–æ—Ä–∏–≥—É—î–º–æ L —Ñ–æ—Ä–º–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–æ—Ç–∞—Ü—ñ—ó
                const rotationNorm = Math.abs(Math.round(rotation / 90) % 4);
                if (block.blockGroupType === 3) {
                    if (rotationNorm === 0) {
                        rotatedShape = [[0, -1], [1, -1], [1, 0], [1, 1]];
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    } else if (rotationNorm === 2) {
                        rotatedShape = [[0, -1], [0, 0], [0, 1], [1, 1]];
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    }
                }
                if (block.blockGroupType === 4 && rotationNorm === 2) {
                    gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                }
                // ShortL –∑ —Ä–æ—Ç–∞—Ü—ñ—î—é 180¬∞ —Ç–µ–∂ –∑–º—ñ—â—É—î–º–æ
                if (block.blockGroupType === 5 && rotationNorm === 2) {
                    gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                }
                // ShortT: –∫–æ—Ä–∏–≥—É—î–º–æ –ø–æ–∑–∏—Ü—ñ—é —Ç–∞ —Ñ–æ—Ä–º—É (–∞–Ω–∞–ª–æ–≥—ñ—á–Ω–æ –¥–æ drawLevel)
                if (block.blockGroupType === 8) {
                    const shortTShapes = {
                        0: [[-1, 0], [0, 0], [1, 0], [0, 1]],
                        1: [[0, -1], [0, 0], [1, 0], [0, 1]],
                        2: [[0, -1], [-1, 0], [0, 0], [1, 0]],
                        3: [[0, -1], [-1, 0], [0, 0], [0, 1]]
                    };
                    rotatedShape = shortTShapes[rotationNorm] || shortTShapes[0];
                    
                    if (rotationNorm === 0) {
                        gridPos = { row: gridPos.row - 1, col: gridPos.col };
                    } else if (rotationNorm === 1) {
                        gridPos = { row: gridPos.row, col: gridPos.col - 1 };
                    } else if (rotationNorm === 2) {
                        if (block.position.y > 0) {
                            gridPos = { row: gridPos.row + 1, col: gridPos.col };
                        }
                    }
                    // rotZ=3: –±–µ–∑ –∑—Å—É–≤—É
                }
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ü—è –∫–ª—ñ—Ç–∏–Ω–∫–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –±–ª–æ–∫—É
                for (const [dx, dy] of rotatedShape) {
                    const blockCol = gridPos.col + dx;
                    const blockRow = gridPos.row + dy;
                    
                    if (blockCol === col && blockRow === row) {
                        return block;
                    }
                }
            }
            
            return null;
        }
        
        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è tooltip
        function showBlockTooltip(block, mouseX, mouseY) {
            if (!block) {
                tooltip.classList.remove('show');
                return;
            }
            
            const colorName = ['–ß–µ—Ä–≤–æ–Ω–∏–π', '–ñ–æ–≤—Ç–∏–π', '–ó–µ–ª–µ–Ω–∏–π', '–°–∏–Ω—ñ–π', '–§—ñ–æ–ª–µ—Ç–æ–≤–∏–π', 
                              '–ë—ñ—Ä—é–∑–æ–≤–∏–π', '–†–æ–∂–µ–≤–∏–π', '–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π', '–°–≤—ñ—Ç–ª–æ-—Ä–æ–∂–µ–≤–∏–π', 
                              '–¢–µ–º–Ω–æ-—Å—ñ—Ä–∏–π', '–ö–æ—Ä–∞–ª–æ–≤–∏–π'][block.blockType] || `–ö–æ–ª—ñ—Ä ${block.blockType}`;
            
            tooltip.innerHTML = `
                <h3>–ë–ª–æ–∫</h3>
                <p><span class="label">blockGroupType:</span> <span class="value">${block.blockGroupType}</span></p>
                <p><span class="label">blockType:</span> <span class="value">${block.blockType} (${colorName})</span></p>
                <p><span class="label">blockGroupTypeName:</span> <span class="value">${block.blockGroupTypeName || 'N/A'}</span></p>
                <p><span class="label">Position:</span> <span class="value">(${block.position.x.toFixed(2)}, ${block.position.y.toFixed(2)})</span></p>
                <p><span class="label">Rotation:</span> <span class="value">${block.rotation.y || 0}¬∞</span></p>
            `;
            
            tooltip.classList.add('show');
            
            // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ tooltip –±—ñ–ª—è –∫—É—Ä—Å–æ—Ä–∞
            const tooltipWidth = tooltip.offsetWidth || 250;
            const tooltipHeight = tooltip.offsetHeight || 150;
            const offset = 15;
            
            let left = mouseX + offset;
            let top = mouseY + offset;
            
            // –Ø–∫—â–æ tooltip –≤–∏—Ö–æ–¥–∏—Ç—å –∑–∞ –º–µ–∂—ñ –µ–∫—Ä–∞–Ω–∞, –∑–º—ñ—â—É—î–º–æ –π–æ–≥–æ
            if (left + tooltipWidth > window.innerWidth) {
                left = mouseX - tooltipWidth - offset;
            }
            if (top + tooltipHeight > window.innerHeight) {
                top = mouseY - tooltipHeight - offset;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –æ–±—Ä–æ–±–Ω–∏–∫—ñ–≤ –ø–æ–¥—ñ–π –¥–ª—è tooltip
        function setupTooltipHandlers() {
            // –í–∏–¥–∞–ª—è—î–º–æ —Å—Ç–∞—Ä—ñ –æ–±—Ä–æ–±–Ω–∏–∫–∏ —è–∫—â–æ —î
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseleave', handleMouseLeave);
            
            // –î–æ–¥–∞—î–º–æ –Ω–æ–≤—ñ –æ–±—Ä–æ–±–Ω–∏–∫–∏
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', handleMouseLeave);
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const block = getBlockAtPosition(mouseX, mouseY);
            showBlockTooltip(block, e.clientX, e.clientY);
        }
        
        function handleMouseLeave() {
            tooltip.classList.remove('show');
        }
        
        // –ì–∞—Ä—è—á—ñ –∫–ª–∞–≤—ñ—à—ñ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') prevLevel();
            if (e.key === 'ArrowRight') nextLevel();
        });
        
        // ========== VERIFICATION SYSTEM ==========
        // –°–ø–∏—Å–æ–∫ –≤–µ—Ä–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏—Ö —Ä—ñ–≤–Ω—ñ–≤ (game level numbers)
        const verifiedLevels = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]);
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –ø–æ—Ç–æ—á–Ω–∏–π —Ä—ñ–≤–µ–Ω—å –≤–µ—Ä–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏–π
        function isCurrentLevelVerified() {
            return verifiedLevels.has(currentLevelIndex + 1);
        }
        
        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è badge –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—ó –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ä—ñ–≤–Ω—è
        function updateVerificationBadge() {
            const nameEl = document.getElementById('levelName');
            const existingBadge = nameEl.querySelector('.verified-badge');
            if (existingBadge) existingBadge.remove();
            
            if (isCurrentLevelVerified()) {
                const badge = document.createElement('span');
                badge.className = 'verified-badge';
                badge.textContent = '‚úì';
                nameEl.appendChild(badge);
            }
        }
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ
        loadLevelsData();
    </script>
</body>
</html>

